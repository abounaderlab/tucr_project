---
title: "Predicting Genetic Relationships"
author: "Myron Keith Gibert Jr"
date: "2022-02-10"
output: pdf_document
urlcolor: cyan
linkcolor: cyan
header-includes:
- \usepackage{hyperref}
- \hypersetup{
    colorlinks=true,
    filecolor=magenta,      
    pdfpagemode=FullScreen,
    }
toc: TRUE
---

\thispagestyle{empty}
\clearpage
\pagenumbering{arabic} 
\pagebreak

```{r tinytex, include=FALSE}
## INSTALLING LATEX FOR RMARKDOWN
#RMarkdown requires LaTex to create pdf documents as an output. More information can be found [here](https://bookdown.org/yihui/rmarkdown/pdf-document.html). Alternatively, output can be set to "html_document" or "word_document". End users may install LaTex by setting the "wanttinytex" variable to FALSE and running the following script:
#Install tinytex to let RMarkdown create a pdf document? Default: wanttinytex <- FALSE
wanttinytex <- TRUE
if(wanttinytex == TRUE){
if(tinytex:::is_tinytex()==FALSE && wanttinytex == TRUE){
  if (!require("tinytex")) install.packages("tinytex")
  tinytex::install_tinytex()
  tinytex:::install_prebuilt()}
library("tinytex")
#tlmgr_install("fvextra")
}
```

https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/

# Introduction

## Setup

I will be using the tidyverse and reshape packages for general data wrangling and manipulation.  The ggplot2 and ggthemes packages are used for visualization. Lastly, rlang is a dependency for tidymodels, the package that I'll be using for statistical modeling of the data.

This setup chunk will set chunk options. Then, it installs packages (if needed) and then loads them into R. 

```{r setup}

knitr::opts_chunk$set(
	#eval = FALSE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)

if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse")

if (!require("ggplot2")) install.packages("ggplot2")
library("ggplot2")

if (!require("ggthemes")) install.packages("ggthemes")
library("ggthemes")


if (!require("RColorBrewer")) install.packages("RColorBrewer")
library("RColorBrewer")



if (!require("rlang")) install.packages("rlang")
library("rlang")

if (!require("tidymodels")) install.packages("tidymodels")
library("tidymodels")

if (!require("reshape2")) install.packages("reshape2")
library("reshape2")

# Load the WGCNA package
if (!require("impute")) BiocManager::install("impute")
library(impute)

if (!require("preprocessCore")) BiocManager::install("preprocessCore")
library(preprocessCore)

if (!require("Go.db")) BiocManager::install("GO.db")
library(GO.db)


if (!require("WGCNA")) install.packages("WGCNA")
library(WGCNA)

if (!require("umap")) install.packages("umap")
library(umap)

if (!require("igraph")) install.packages("igraph")
library(igraph)

## Variables

outputdir <- "WGCNA"

filterannot <- "TUCR"

set.seed(20240129)

```

```{r_createoutputdir}

if(!dir.exists(outputdir)){
  dir.create(outputdir)
}

```


### Data Input 1: Preprocessing

```{r datainput_1,eval=FALSE}

## Set-up

  mergedcounts_GBM <- read.table("GBM_mergedcounts.txt",header = TRUE)
  
  mergedcounts_LGG <- read.table("LGG_mergedcounts.txt",header = TRUE)
  
  normalcounts_cortex <- read.table("cortex_mergedcounts.txt",header = TRUE) 
  
  mergedcounts <- mergedcounts_GBM %>% left_join(mergedcounts_LGG,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y,-alias.y) %>%
    dplyr::rename("chrom" = chrom.x,"start" = start.x,"end" = end.x,"strand" = strand.x,"tag" = tag.x, "alias" = alias.x, "annot" = annot.x) %>%
    distinct()
  
   mergedcounts <- mergedcounts %>% left_join(normalcounts_cortex,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y,-alias.y) %>%
    distinct()
   
  rm(mergedcounts_GBM,mergedcounts_LGG,normalcounts_cortex)
   
  metadata_GBM <- read_csv(file = "GBM_tcga_metadata.csv")
  
  metadata_LGG <- read_csv(file = "LGG_tcga_metadata.csv")
  
  metadata_cortex <- read_csv(file = "cortex_gtex_metadata.csv")
  
  metadata <- rbind(metadata_GBM,metadata_LGG,metadata_cortex)
  
  
  rm(metadata_GBM,metadata_LGG,metadata_cortex)
  
  seqdepth_GBM <- read.csv(file = "GBM_seqdepth_counts.csv")
  
  seqdepth_LGG <- read.csv(file = "LGG_seqdepth_counts.csv")
  
  seqdepth_cortex <- read.csv(file = "cortex_seqdepth_counts.csv")
  
  seqdepth <- rbind(seqdepth_GBM,seqdepth_LGG,seqdepth_cortex)
  
  rm(seqdepth_GBM,seqdepth_LGG,seqdepth_cortex)

```

### Setting color palette

```{r colors}

paper_black = "#000000"
  
paper_gold = "#EAA304"
  
paper_green2 = "#20C799"
  
paper_yellow = "#F0E442"
  
paper_blue = "#017DC3"
  
paper_lightblue = "#58AFE0"
  
paper_skyblue = "#A5DFFF"
  
paper_orange = "#D55E00"
  
paper_purple = "#8C004C"
  
paper_gray = "#CAC4C4"
  
paper_red = "#C30223"
  
paper_darkpink = "#DA7C8C"
  
paper_pink = "#FFCCD5"

paper_green = "#54BB44"
  
paper_red2 = "#CA465C"
  
paper_turq = "#20C799"

```

## Data Input and Cleaning

```{r datainput_2,eval=FALSE}

rpkmcounts <- mergedcounts %>%
  mutate(length = end.x - start.x)

rpkmcounts.info <- rpkmcounts %>%
  dplyr::select("chrom" = chrom.x,"start" = start.x,"end" = end.x,"strand"=strand.x,id,"alias"=alias.x,"tag"=tag.x,"annot" = annot.x,length)

rpkmcounts <- rpkmcounts %>%
  dplyr::select(-chrom.x,-start.x,-end.x,-id,-strand.x,-tag.x,-annot.x,-alias.x,-length)
  
rownames(rpkmcounts) <- as.character(rpkmcounts.info$id)

genelength <- rpkmcounts.info$length/1000

seqdepth2 <- as.vector(seqdepth$counts)/1000000

rpkm <- function(counts,len,dep){
  #x <- rpkmcounts/genelength
  #x2 <- t(t(x)/(seqdepth2))
  x <- counts/len
  return(t(t(x)/(dep)))
}

rpkm.df <- rpkm(rpkmcounts,genelength,seqdepth2)

rpkm.df <- cbind(rpkmcounts.info,rpkm.df)

mergedcounts2 <- rpkm.df %>%
  filter(annot != "random")

rm(rpkm.df,rpkmcounts,rpkmcounts.info,seqdepth)

datExpr0 <- as.data.frame(t(mergedcounts2[, -c(1:9)]))
names(datExpr0) <- mergedcounts2$id
rownames(datExpr0) <- names(mergedcounts2)[-c(1:9)]

```

We first check for genes and samples with too many missing values

```{r  datainput_3,eval=FALSE}

gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK

```

If the last statement returns TRUE, all genes have passed the cuts. If not, we remove the offending genes and samples
from the data:

```{r  datainput_4,eval=FALSE}

if (!gsg$allOK){
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0) 
     printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0) 
     printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}


```

Next we cluster the samples (in contrast to clustering genes that will come later) to see if there are any obvious
outliers.

```{r  datainput_5,fig.height=9,fig.width=12,eval=FALSE}

sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(120,120)
pdf(file = "sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

```

It appears there is one outlier (sample F2_221, see Fig. 1). One can remove it by hand, or use an automatic approach.

Choose a height cut that will remove the offending sample, say 15 (the red line in the plot), and use a branch cut at that height.

```{r  datainput_6,eval=FALSE}

# Determine cluster under the line
#clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10)
#table(clust)
# clust 1 contains the samples we want to keep.
#keepSamples = (clust==1)
#datExpr = datExpr0[keepSamples, ]
datExpr = datExpr0[]
newcolnames <- colnames(datExpr)
newrownames <- row.names(datExpr)
datExpr <- matrix(as.numeric(unlist(datExpr)),    # Convert to numeric matrix
                  ncol = ncol(datExpr))
colnames(datExpr) <- newcolnames
row.names(datExpr) <- newrownames
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

```

The variable datExpr now contains the expression data ready for network analysis.

We now read in the trait data and match the samples for which they were measured to the expression samples.

```{r  datainput_7,eval=FALSE}

tucrcounts <- mergedcounts %>%
  #filter(alias.x == "LINC00643" | alias.x == "SOX21-AS1" | tag.x == "TUCR" & annot.x != "random") %>%
  filter(tag.x == "TUCR" & annot.x != "random") %>%
  dplyr::select(-chrom.x,-start.x,-end.x,-strand.x,-annot.x,-tag.x,-id)

rownames(tucrcounts) <- tucrcounts$alias.x

tucrcolumns <- colnames(tucrcounts[,2:length(colnames(tucrcounts))])

tucrcounts <- tucrcounts[,-1]

tucrcounts <- t(tucrcounts) 

tucrcounts <- cbind(tucrcolumns,tucrcounts)

colnames(tucrcounts)[1] <- "survid"

tucrcounts <- as.data.frame(tucrcounts)

traitData <- metadata %>%
  left_join(tucrcounts,by="survid")

# remove columns that hold information we do not need.
allTraits = traitData[, -c(1,3)]

# Form a data frame analogous to expression data that will hold the clinical traits.

tcgaSamples = rownames(datExpr)
traitRows = match(tcgaSamples, allTraits$survid)
datTraits = allTraits
newrows <- allTraits[traitRows,2]
rownames(datTraits) <- as.character(datTraits$survid)
datTraits2 <- datTraits %>%
  mutate(dex2 = ifelse(dex == "tumor",1,0),p53status2 = ifelse(p53status == "WT",0,1)) %>%
  dplyr::select(-survid,-dex,-p53status)

newcolnames <- colnames(datTraits2)

datTraits2 <- matrix(as.numeric(unlist(datTraits2)),    # Convert to numeric matrix
                  ncol = ncol(datTraits2))
rownames(datTraits2) <- as.character(datTraits$survid)
colnames(datTraits2) <- newcolnames

is.numeric(datTraits2)

collectGarbage()
```


```{r  datainput_9,eval=FALSE}

save(datExpr, datTraits2, file = "TUCR-01-dataInput.RData")

```

## Network construction and module detection

### Automatic, one-step network construction and module detection

This step is the bedrock of all network analyses using the WGCNA methodology. We present three different ways of
constructing a network and identifying modules:

a. Using a convenient 1-step network construction and module detection function, suitable for users wishing to arrive
at the result with minimum effort;
b. Step-by-step network construction and module detection for users who would like to experiment with customized/alternate methods;
c. An automatic block-wise network construction and module detection method for users who wish to analyze data
sets too large to be analyzed all in one.
In this tutorial section, we illustrate the 1-step, automatic network construction and module detection.


```{r automaticnetwork_1,eval=FALSE}

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE);
# Allow multi-threading within WGCNA. This helps speed up certain calculations.
# At present this call is necessary for the code to work.
# Any error here may be ignored but you may want to update WGCNA if you see one.
# Caution: skip this line if you run RStudio or other third-party R environments. 
# See note above.
#enableWGCNAThreads()
# Load the data saved in the first part
lnames = load(file = "TUCR-01-dataInput.RData");
#The variable lnames contains the names of loaded variables.
lnames

```

We have loaded the variables datExpr and datTraits containing the expression and trait data, respectively.

Constructing a weighted gene network entails the choice of the soft thresholding power β to which co-expression
similarity is raised to calculate adjacency [1]. The authors of [1] have proposed to choose the soft thresholding power
based on the criterion of approximate scale-free topology. We refer the reader to that work for more details; here
we illustrate the use of the function pickSoftThreshold that performs the analysis of network topology and aids the
user in choosing a proper soft-thresholding power. The user chooses a set of candidate powers (the function provides
suitable default values), and the function returns a set of network indices that should be inspected, for example as
follows:

```{r automaticnetwork_2,eval=FALSE}

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
{plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")}
# Mean connectivity as a function of the soft-thresholding power
{plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")}

```

The result is shown in Fig. 1. We choose the power 6, which is the lowest power for which the scale-free topology fit
index curve flattens out upon reaching a high value (in this case, roughly 0.90).

Constructing the gene network and identifying modules is now a simple function call:

```{r automaticnetwork_3,eval=FALSE}

#net2 = blockwiseModules(datExpr, power = 8,maxBlockSize=15000,
#                       TOMType = "unsigned", minModuleSize = 30,
#                       reassignThreshold = 0.05, mergeCutHeight = 0.25,
#                       deepSplit = 2,randomSeed = 20240219,
#                       numericLabels = TRUE, pamRespectsDendro = FALSE,
#                       saveTOMs = TRUE, saveTOMFileBase = "TUCRTOM", 
#                       verbose = 3)

net = blockwiseModules(datExpr, power = 8,maxBlockSize=15000,
                      TOMType = "unsigned", minModuleSize = 30,
                      reassignThreshold = 0.05, mergeCutHeight = 0.40,
                      deepSplit = 2,randomSeed = 20240219,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE, saveTOMFileBase = "TUCRTOM", 
                       verbose = 3)

#net3 = blockwiseModules(datExpr, power = 8,maxBlockSize=15000,
#                       TOMType = "unsigned", minModuleSize = 60,
#                       reassignThreshold = 0.05, mergeCutHeight = 0.25,
##                       deepSplit = 2,randomSeed = 20240219,
#                       numericLabels = TRUE, pamRespectsDendro = FALSE,
#                       saveTOMs = TRUE, saveTOMFileBase = "TUCRTOM", 
#                       verbose = 3)

#save(net,net2,net3,file="nets.Rdata")

```

We have chosen the soft thresholding power 6, a relatively large minimum module size of 30, and a medium sensitivity
(deepSplit=2) to cluster splitting. The parameter mergeCutHeight is the threshold for merging of modules. We have
also instructed the function to return numeric, rather than color, labels for modules, and to save the Topological
Overlap Matrix. The output of the function may seem somewhat cryptic, but it is easy to use. 

For example,net$colors contains the module assignment, and net$MEs contains the module eigengenes of the modules.

A word of caution for the readers who would like to adapt this code for their own data. The function
blockwiseModules has many parameters, and in this example most of them are left at their default value. We
have attempted to provide reasonable default values, but they may not be appropriate for the particular data set
the reader wishes to analyze. We encourage the user to read the help file provided within the package in the R environment and experiment with tweaking the network construction and module detection parameters. The potential
reward is, of course, better (biologically more relevant) results of the analysis.

A second word of caution concerning block size. In particular, the parameter maxBlockSize tells the function
how large the largest block can be that the reader’s computer can handle. The default value is 5000 which is
appropriate for most modern desktops. Note that if this code were to be used to analyze a data set with more than
5000 probes, the function blockwiseModules will split the data set into several blocks. This will break some of the
plotting code below, that is executing the code will lead to errors. Readers wishing to analyze larger data sets need
to do one of the following:

• If the reader has access to a large workstation with more than 4 GB of memory, the parameter maxBlockSize
can be increased. A 16GB workstation should handle up to 20000 probes; a 32GB workstation should handle
perhaps 30000. A 4GB standard desktop or a laptop may handle up to 8000-10000 probes, depending on
operating system and how much memory is in use by other running programs.

• If a computer with large-enough memory is not available, the reader should follow Section 2.c, Dealing with
large datasets, and adapt the code presented there for their needs. In general it is preferable to analyze a data
set in one block if possible, although in Section 2.c we present a comparison of block-wise and single-block
analysis that indicates that the results are very similar.

colors are from https://mokole.com/palette.html

```{r automaticnetwork_4,eval=FALSE}

#load(file="nets.Rdata")

if(!dir.exists(paste(outputdir,"/dendrograms/",sep=""))){
  dir.create(paste(outputdir,"/dendrograms/",sep=""))
}

# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting

moduleLabels = net$colors
MEs = net$MEs;

##getcolors

n <- length(MEs)
dat_brewer <- read.csv("colorcodelist.csv",header=F)

col_vector = as.character(dat_brewer$V2)

pie(rep(1,n), col=col_vector[2:n])


#moduleColors = labels2colors(net$colors,colorSeq=col_vector[1:n])
moduleColors = col_vector[moduleLabels + 1]
genetree = net$dendrograms[[1]];


# Plot the dendrogram and the module colors underneath

i <- 1
for(i in 1:length(net$dendrograms)){
  print(i)
png(file=paste(outputdir,"/dendrograms/net_wgcna_dendrogram_plot",i,".png",sep=""))
plotDendroAndColors(dendro = net$dendrograms[[i]], colors = moduleColors[net$blockGenes[[i]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()
  
}

save(net,MEs, moduleLabels, moduleColors, geneTree, 
     file = "TUCR-02-networkConstruction-auto.RData")

```

### Step-by-step network construction and module detection

### Dealing with large datasets: block-wise network construction and module detection

## Relating modules to external clinical traits and identifying important genes

```{r relatingmodules_1}

# Load the WGCNA package
library(WGCNA)
# The following setting is important, do not omit.
options(stringsAsFactors = FALSE)
# Load the expression and trait data saved in the first part
lnames = load(file = "TUCR-01-dataInput.RData")
#The variable lnames contains the names of loaded variables.
lnames
# Load network data saved in the second part.
lnames = load(file = "TUCR-02-networkConstruction-auto.RData")
lnames

```
filter out modules that are particularly large. 

```{r relatingmodules_2,fig.width = 3, fig.height = 7}

# Define numbers of genes and samples
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes

datExpr2 = as.data.frame(datExpr)
MEs = orderMEs(MEs0)
datTraits2 <- as.data.frame(datTraits2)
moduleTraitCor = cor(MEs, datTraits2, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

```

```{r,relatingmodules_3}

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))

allmodules <- as.data.frame(t(MMPvalue))

allmodules2 <- allmodules %>%
  dplyr::mutate(Module = row.names(allmodules)) %>%
  gather(key = "Gene", value = "pvalue",-Module) %>%
  group_by(Gene) %>%
  mutate(maxmodule = min(pvalue,na.rm = TRUE)) %>%
  filter(pvalue == maxmodule) %>%
  group_by(Module) %>%
  dplyr::summarize(n = n()) 

allmodules3 <- allmodules2 %>%
  mutate(q1 = quantile(allmodules2$n,0.25),q3 = quantile(allmodules2$n,0.75),q1minus = q1 - 1.5*(q3-q1),q3plus = q3 + 1.5*(q3-q1),outliercheck = ifelse(n >= q3plus | n <= q1minus,TRUE,FALSE)) 
#%>%  filter(outliercheck == FALSE)

#repeat{
  
n_count <- length(allmodules3$n)

allmodules3 <- allmodules3 %>%
  mutate(q1 = quantile(allmodules3$n,0.25),q3 = quantile(allmodules3$n,0.75),q1minus = q1 - 1.5*(q3-q1),q3plus = q3 + 1.5*(q3-q1),outliercheck = ifelse(n >= q3plus | n <= q1minus,TRUE,FALSE)) 
#%>% filter(outliercheck == FALSE)

#if(n_count == length(allmodules3$n)) break;

#  }

allmodules_check <- as.data.frame(as.character(allmodules3$Module)) %>%
  dplyr::mutate(checker = TRUE)

colnames(allmodules_check) <- c("Module","checker")

boxplot(allmodules3$n,
  ylab = "n"
)

moduleTraitCor2 <- as.data.frame(moduleTraitCor) %>%
  mutate(Module = row.names(moduleTraitCor)) %>%
  left_join(allmodules_check,by = "Module") %>%
  filter(checker == TRUE)

datTraits <- datTraits2

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

match_modules <- match(as.character(allmodules_check$Module),colnames(geneModuleMembership))

geneModuleMembership2 <- geneModuleMembership[,match_modules]

modNames = substring(names(geneModuleMembership2), 3)

MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))

match_modules <- match(as.character(allmodules_check$Module),colnames(MMPvalue))

MMPvalue2 = MMPvalue[,match_modules]

names(geneModuleMembership2) = paste("MM", modNames, sep="")
names(MMPvalue2) = paste("p.MM", modNames, sep="")

save.image(file="~/tucr_project/allprelims.Rdata")

```

In this analysis we would like to identify modules that are significantly associated with the measured clinical traits.
Since we already have a summary profile (eigengene) for each module, we simply correlate eigengenes with external
traits and look for the most significant associations:

The analysis identifies the several significant module–trait associations. We will concentrate on weight as the trait
of interest.

We quantify associations of individual genes with our trait of interest (weight) by defining Gene Significance GS as
(the absolute value of) the correlation between the gene and the trait. For each module, we also define a quantitative
measure of module membership MM as the correlation of the module eigengene and the gene expression profile. This
allows us to quantify the similarity of all genes on the array to every module.

Using the GS and MM measures, we can identify genes that have a high significance for weight as well as high module
membership in interesting modules. As an example, we look at the brown module that has the highest association
with weight. We plot a scatterplot of Gene Significance vs. Module Membership in the brown module:

```{r Figure1_mainheatmap}

load(file="~/tucr_project/allprelims.Rdata")

if(!dir.exists(outputdir)){
  dir.create(outputdir)
}

#datTraits2 <- datTraits2

datTraits2 <- datTraits2 %>%
  dplyr::select(-disease)

datTraits <- as.data.frame(t(datTraits2)) %>%
  mutate(rownames = row.names(t(datTraits2))) %>%
  #filter(rownames == trait_id) %>%
  dplyr::select(-rownames) %>%
  t()

hc.Traits <- hclust(dist(t(datTraits2)))

clust_order_traits <- hc.Traits$order

clust_positions <- as.data.frame(cbind(as.character(colnames(datTraits)[clust_order_traits]),as.numeric(clust_order_traits)))

colnames(clust_positions) <- c("trait","clust_order")

geneTraitSignificance <- as.data.frame(cor(datExpr,datTraits2, use = "p")) %>%
  dplyr::select(-dex2,-p53status2)

GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

#names(geneTraitSignificance) = paste("GS.", names(weight), sep="")
#names(GSPvalue) = paste("p.GS.", names(weight), sep="")

moduleTraitCor_trait_id <- as.data.frame(moduleTraitCor2) %>%
  mutate(modules = str_remove(Module,"ME")) %>%
  gather(key = "trait", value = "cor",-modules,-Module,-checker,-p53status2,-dex2) %>%
  #filter(is.numeric(cor)) %>%
  #filter(trait == trait_id) %>%
  dplyr::group_by(trait) %>%
  arrange(desc(cor)) %>%
  ungroup() %>%
  dplyr::group_by(modules) %>%
  dplyr::mutate(sumnumber = sum(cor,na.rm=T),
         n = n(),
         weight = sumnumber/n) %>%
  ungroup() %>%
  arrange(desc(weight))

traitpositions <- moduleTraitCor_trait_id %>%
  dplyr::select(modules) %>%
  distinct() %>%
  dplyr::mutate(position = row_number())

moduleTraitCor_trait_id <- moduleTraitCor_trait_id %>%
  left_join(traitpositions,by="modules") %>%
  left_join(clust_positions,by="trait") 

moduleTraitCor_trait_id <- moduleTraitCor_trait_id %>% 
  mutate(clust_position_order = as.numeric(moduleTraitCor_trait_id$clust_order))

p <- ggplot(data = moduleTraitCor_trait_id,mapping = aes(x = reorder(modules,position),y = reorder(trait,clust_position_order), fill = as.numeric(cor))) +
  geom_tile() +
  scale_fill_gradient2(low = paper_blue,mid = "white",high = paper_red2,midpoint = 0) +
  ylab("TUCRs") +
  xlab("Modules") +
  labs(fill = "cor") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.title = element_text(size = rel(2.2), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
        axis.title = element_text(size = rel(1.8), face="bold"),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
        legend.position="right",
        legend.title=element_text(size = rel(2.5), face="bold"),
        legend.text=element_text(size = rel(2.0), face="bold"), 
        plot.margin = unit(c(0,0,0,0), "cm")) +
        annotate(
    geom = "point",
    color = c(as.character(moduleTraitCor_trait_id$modules)),
    x = moduleTraitCor_trait_id$position, 
    y = 0.5,
    shape = 15, 
    size = 5)

p

ggsave(p,file=paste(outputdir,"/allTraits_heatmap.png",sep=""), width = 7, height = 3, dpi = 300)
```

```{r figure2_allgoterms}

if(!dir.exists(paste(outputdir,"/GO_Terms/",sep=""))){
  dir.create(paste(outputdir,"/GO_Terms/",sep=""))
}

#####GO-TERM ANALYSIS

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

if (!require('GO.db')) BiocManager::install('GO.db')
library(GO.db)

#if (!require('AnnotationDBI')) BiocManager::install('AnnotationDBI')
#library(AnnotationDBI)

if (!require('org.Hs.eg.db')) BiocManager::install('org.Hs.eg.db')
library(org.Hs.eg.db)

if (!require('GO.db')) BiocManager::install('GO.db')
library(GO.db)

if (!require('limma')) BiocManager::install('limma')
library(limma)

i <- 1

genelist <- geneTraitSignificance %>%
  mutate(genenames = row.names(geneTraitSignificance))

for(i in 1:length(unique(moduleTraitCor_trait_id$modules))){
  
  print(i)
  print(unique(moduleTraitCor_trait_id$modules)[i])
  
  module <- unique(moduleTraitCor_trait_id$modules)[i]
  #module <- "yellowgreen"
  column = match(module, modNames);
  moduleGenes = moduleColors==module;
  
  genelist2 <- as.data.frame(genelist[moduleGenes,])
  
  genelist2 <- genelist2 %>%
    separate(genenames,into=c("Alias","kibble"),sep="___")
 
  symbols <- as.character(genelist2$Alias)
  
  EntrezIDs <- mapIds(org.Hs.eg.db, symbols, 'ENTREZID', 'SYMBOL')
  allgenes <- cbind(symbols,EntrezIDs)
  allgenes <- allgenes[complete.cases(allgenes),]
  
  g <- goana(EntrezIDs)
  
  g_bp <- g %>%
    filter(Ont == "BP")
  topGO_bp <- topGO(g_bp) %>%
    mutate(log10_p = -log10(P.DE),module=module,color="red") %>%
    arrange(desc(log10_p))
  
  g_mf <- g %>%
    filter(Ont == "MF")
  topGO_mf <- topGO(g_mf) %>%
    mutate(log10_p = -log10(P.DE),module=module,color="blue") %>%
    arrange(desc(log10_p))
  
  topGO_all <- rbind(topGO_bp,topGO_mf) %>%
                       arrange(as.numeric(log10_p)) %>%
                       dplyr::mutate(roworder = row_number()) %>%
                       mutate(newTerm = substr(Term,1,80))
  
  p <- ggplot(topGO_all,aes(x=reorder(newTerm,roworder),y=as.numeric(log10_p),fill=module,color=color)) +
    geom_bar(stat="identity") + coord_flip() + scale_fill_identity() + scale_color_identity() + facet_wrap(~Ont,scales="free",ncol=1) + 
    ggtitle(module) +
    labs(x="Go Term", y = "-log10(p-value)") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.title = element_text(size = rel(2.2), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
        axis.title = element_text(size = rel(1.8), face="bold"),
        axis.text.y = element_text(size = rel(1.4), face="bold"),
        axis.text.x = element_text(size = rel(1.4), face="bold",angle=0,vjust = 0.5, hjust=1),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
        legend.position="none",
        legend.title=element_blank(),
        legend.text=element_blank(),
        strip.text.x = element_text(size = rel(2.2)))
  p
  
ggsave(plot = print(p),paste(outputdir,"/GO_Terms/",module,"_all_bar.png",sep=""),height=8,width=16)
}

```


```{r relatingmodules_5,fig.height=7,fig.width=3}

####Trait Heatmaps

#moduleTraitCor2 <- moduleTraitCor2 %>%
#  dplyr::select(-disease)

h <- 172

for(h in 1:length(colnames(moduleTraitCor2))){
skip_to_next <<- FALSE
print(h)
trait_id <- colnames(moduleTraitCor2)[h]
#trait_id <-"uc.15"

print(trait_id)
if(dir.exists(paste("WGCNA/",trait_id,sep=""))) {skip_to_next <<- TRUE}
  
if(skip_to_next) { next }

if(!dir.exists(paste("WGCNA/",trait_id,sep=""))){
  dir.create(paste("WGCNA/",trait_id,sep=""))
}

datTraits <- as.data.frame(t(datTraits2)) %>%
  mutate(rownames = row.names(t(datTraits2))) %>%
  filter(rownames == trait_id) %>%
  dplyr::select(-rownames) %>%
  t()

geneTraitSignificance = as.data.frame(cor(datExpr,datTraits, use = "p"))

GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

names(geneTraitSignificance) = paste("GS.", names(weight), sep="")
names(GSPvalue) = paste("p.GS.", names(weight), sep="")

moduleTraitCor_trait_id <- as.data.frame(moduleTraitCor2) %>%
  dplyr::mutate(modules = str_remove(Module,"ME")) %>%
  gather(key = "trait", value = "cor",-modules) %>%
  dplyr::filter(trait == trait_id) %>%
  dplyr::arrange(cor) %>%
  dplyr::mutate(position = row_number())

traitmodules <- geneModuleMembership2 %>%
  dplyr::mutate(rownamer = row.names(geneModuleMembership2)) %>%
  separate(rownamer,into=c("rownamer","kibble"),sep="___") %>%
  dplyr::select(-kibble) %>%
  dplyr::filter(rownamer==trait_id)

traitmodules <- t(traitmodules)

traitmodules <- as.data.frame(cbind(row.names(traitmodules),traitmodules))

colnames(traitmodules) <- c("Module","ModuleMembership")

traitpvalues <- MMPvalue2 %>%
  dplyr::mutate(rownamer = row.names(MMPvalue2)) %>%
  separate(rownamer,into=c("rownamer","kibble"),sep="___") %>%
  dplyr::select(-kibble) %>%
  dplyr::filter(rownamer==trait_id)

traitpvalues <- t(traitpvalues)

traitpvalues <- as.data.frame(cbind(paste("MM",str_remove(row.names(traitpvalues),"p.MM"),sep=""),traitpvalues))

colnames(traitpvalues) <- c("Module","MMpvalue")
traitmodules <- traitmodules %>%
  left_join(allmodules_check, by= "Module") %>%
  left_join(traitpvalues,"Module") %>%
  #filter(checker == TRUE) %>%
  dplyr::mutate(moduleColors = str_remove(Module,"MM")) %>%
  dplyr::filter(moduleColors != "rownamer")

df_correlations <- data.frame(matrix(ncol=2,nrow=0, dimnames=list(NULL, c("module","cor"))))

i <- 1

for(i in 1:length(unique(traitmodules$moduleColors))){

module = as.character(unique(traitmodules$moduleColors)[i])
#module = "red"
column = match(module, modNames)
moduleGenes = traitmodules$moduleColors==module;
correlation <- cor(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]))

rbinder <- c(module,correlation)
df_correlations <- rbind(df_correlations,rbinder)


}

colnames(df_correlations) <- c("module","cor") 

df_correlations <- as.data.frame(df_correlations) %>%
  mutate(Module = paste("MM",module,sep=""))

traitmodules2 <- traitmodules %>%
  left_join(df_correlations,by = "Module") %>%
  dplyr::select(module,cor,ModuleMembership,MMpvalue) %>%
  mutate(RankModule = percent_rank(1-as.numeric(ModuleMembership)),Rankcor = percent_rank(cor),MMpvalue2 = as.numeric(MMpvalue)) %>%
  group_by(module) %>%
  mutate(totalscore = sum(as.numeric(RankModule),as.numeric(Rankcor),na.rm=TRUE)) %>%
  ungroup() %>%
  arrange(as.numeric(cor)) %>%
  mutate(position = row_number(),cor = ifelse(MMpvalue2 >= 0.05,NA,cor))
  

p <- ggplot(data = traitmodules2,mapping = aes(x = as.character(trait_id),y = reorder(module,position), fill = as.numeric(cor))) +
  geom_tile() +
  scale_fill_gradient2(low = paper_blue,mid = "white",high = paper_red2,midpoint = 0) +
  ylab("modules") +
  xlab(trait_id) +
  labs(fill = "cor") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.title = element_text(size = rel(2.2), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
        axis.title = element_text(size = rel(1.8), face="bold"),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
        legend.position="right",
        legend.title=element_text(size = rel(2.5), face="bold"),
        legend.text=element_text(size = rel(2.0), face="bold"), 
        plot.margin = unit(c(0,0,0,0), "cm")) +
        annotate(
    geom = "point",
    color = c(as.character(traitmodules2$module)),
    y = traitmodules2$position, 
    x = 0.5,
    shape = 15, 
    size = 5)

#p

ggsave(p,file=paste("WGCNA/",trait_id,"/",trait_id,"_heatmap.png",sep=""), width = 3, height = 7, dpi = 300)

####Trait Correlation Plots

traitmodules3 <- traitmodules2 %>%
  filter(as.numeric(MMpvalue) <= 0.05)



i <- 1

for(i in 1:length(traitmodules3$module)){

module = as.character(traitmodules3$module[i])
print(i)
print(paste(module))
#module = "red"
correlation <- round(as.numeric(traitmodules3$cor[i]),3)
pvalue <- as.numeric(traitmodules3$MMpvalue[i])
column = match(module, modNames);
moduleGenes = moduleColors==module; 
sizeGrWindow(7, 7);
par(mfrow = c(1,1));

xvalues <- tryCatch(abs(geneModuleMembership[moduleGenes, column]),
                error = function(e) { skip_to_next <<- TRUE}) 
yvalues <- abs(geneTraitSignificance[moduleGenes, 1])
ngenes <- length(xvalues)

ggplot_df <- as.data.frame(cbind(xvalues,yvalues))

  


p <- ggplot(ggplot_df,aes(xvalues,yvalues,color=module)) +
  geom_point(size=5) +
  scale_color_identity() +
  xlab(paste("Module Membership in", module, "module")) +
                   ylab("Gene significance for trait") +
  ggtitle(paste(module,"(n = ",ngenes,", cor = ",correlation,", p = ",pvalue,")",sep="")) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.title = element_text(size = rel(1.2), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
        axis.title = element_text(size = rel(1.4), face="bold"),
        axis.text.y = element_text(size = rel(1.4), face="bold"),
        axis.text.x = element_text(size = rel(1.4), face="bold"),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
        legend.position="right",
        legend.title=element_blank(),
        legend.text=element_blank(), 
        plot.margin = unit(c(0,0,0,0), "cm"))

ggsave(plot = print(p),paste("WGCNA/",trait_id,"/",trait_id,"_",module,".png",sep=""),height=5,width=5)

}}

```

```{r relatingmodules_5,eval=FALSE}

traitmodules <- MMPvalue %>%
  mutate(rownamer = row.names(MMPvalue)) %>%
  filter(str_detect(rownamer,"trait"))

traitmodules <- t(traitmodules) 

colnames(traitmodules) <- "ModuleMembership"

traitmodules <- as.data.frame(traitmodules) %>%
  mutate(Modules = row.names(traitmodules),ModuleMembership2 = as.numeric(ModuleMembership)) %>%
  arrange(ModuleMembership2) %>%
  filter(Modules != "rownamer")

df_correlations <- c("module","cor") 

i <- 1

for(i in 1:length(unique(moduleColors))){
  


module = as.character(unique(moduleColors)[i])
#module = "red"
column = match(module, modNames);
moduleGenes = moduleColors==module;
correlation <- cor(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]))
rbinder <- c(module,correlation)
df_correlations <- rbind(df_correlations,rbinder)


}

df_correlations <- as.data.frame(df_correlations) %>%
  mutate(Modules = paste("p.MM",V1,sep=""))

traitmodules2 <- traitmodules %>%
  left_join(df_correlations,by = "Modules") %>%
  dplyr::select("Modules"=V1,"ModuleMembership"=ModuleMembership2,"Correlation"=V2) %>%
  mutate(RankModule = percent_rank(1-ModuleMembership),Rankcor = percent_rank(Correlation)) %>%
  group_by(Modules) %>%
  mutate(totalscore = sum(as.numeric(RankModule),as.numeric(Rankcor),na.rm=TRUE)) %>%
  arrange(desc(totalscore)) %>%
  filter(Correlation >= 0.3,ModuleMembership <= 0.01)

i <- 1

for(i in 1:length(traitmodules2$Modules)){


module = as.character(traitmodules2$Modules[i])
#module = "red"
correlation <- round(as.numeric(traitmodules2$Correlation[i]),3)
column = match(module, modNames);
moduleGenes = moduleColors==module; 
sizeGrWindow(7, 7);
par(mfrow = c(1,1));

xvalues <- abs(geneModuleMembership[moduleGenes, column])
yvalues <- abs(geneTraitSignificance[moduleGenes, 1])
modulecolornames <- colnames(geneModuleMembership)
ngenes <- length(xvalues)

ggplot_df <- as.data.frame(cbind(xvalues,yvalues,modulecolornames)) %>%
  mutate(newcolornames = module)

p <- ggplot(ggplot_df,aes(xvalues,yvalues,color=newcolornames)) +
  geom_point() +
  scale_color_identity() +
  xlab(paste("Module Membership in", module, "module")) +
                   ylab("Gene significance for trait") +
  ggtitle(paste(module,"(n = ",ngenes,", cor = ",correlation,")",sep="")) +
  theme(plot.title = element_text(size = rel(2.2), face="bold"),
              axis.title = element_text(size = rel(2.2), face="bold"),
              axis.text = element_blank(),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
panel.background = element_blank(), axis.line = element_line(colour = "black"),legend.position="top",legend.title=element_blank(),
legend.text=element_text(size=rel(2.2)))

ggsave(plot = print(p),paste("WGCNA/",trait_id,"/",trait_id,"_",module,".png",sep=""),height=8,width=8)

}






```

Clearly, GS and MM are highly correlated, illustrating that genes highly significantly
associated with a trait are often also the most important (central) elements of modules associated with the trait.
The reader is encouraged to try this code with other significance trait/module correlation (for example, the magenta,
midnightblue, and red modules with weight).

We have found modules with high association with our trait of interest, and have identified their central players by
the Module Membership measure. We now merge this statistical information with gene annotation and write out a
file that summarizes the most important results and can be inspected in standard spreadsheet software such as MS
Excel or Open Office Calc. Our expression data are only annotated by probe ID names: the command

## Interfacing network analysis with other data such as functional annotation and gene ontology

The WGCNA package now contains a function to perform GO enrichment analysis using a simple, single step. To
run the function, Biconductor packages GO.db, AnnotationDBI, and the appropriate organism-specific annotation
package(s) need to be installed before running this code. The organism-specific packages have names of the form
org.Xx.eg.db, where Xx stands for organism code, for example, Mm for mouse, Hs for human, etc. The only exception
is yeast, for which no org.Xx.eg.db package is available; instead, the package carries the name org.Sc.sgd.db. Please
visit the Bioconductor main page at http://www.bioconductor.org to download and install the required packages.
In our case we are studying gene expressions from mice, so this code needs the package org.Mm.eg.db. Calling the
GO enrichment analysis function GOenrichmentAnalysis is very simple. The function takes a vector of module labels,
and the Entrez (a.k.a. Locus Link) codes for the genes whose labels are given.

```{r interfacing_3,fig.width=20,fig.height=5,eval=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

if (!require('GO.db')) BiocManager::install('GO.db')
library(GO.db)

#if (!require('AnnotationDBI')) BiocManager::install('AnnotationDBI')
#library(AnnotationDBI)

if (!require('org.Hs.eg.db')) BiocManager::install('org.Hs.eg.db')
library(org.Hs.eg.db)

if (!require('GO.db')) BiocManager::install('GO.db')
library(GO.db)

if (!require('limma')) BiocManager::install('limma')
library(limma)

i <- 1

genelist <- geneTraitSignificance %>%
  mutate(genenames = row.names(geneTraitSignificance))

for(i in 1:length(traitmodules3$module)){
  
  print(i)
  print(traitmodules3$module[i])
  
  module <- traitmodules3$module[i]
  #module <- "cyan"
  column = match(module, modNames);
  moduleGenes = moduleColors==module;
  
  genelist2 <- as.data.frame(genelist[moduleGenes,])
  
  genelist2 <- genelist2 %>%
    separate(genenames,c("Alias","kibble"),"___")
 
  symbols <- as.character(genelist2[,2])
  
  EntrezIDs <- mapIds(org.Hs.eg.db, symbols, 'ENTREZID', 'SYMBOL')
  genelist2 <- cbind(genelist2,EntrezIDs)
  genelist3 <- genelist2[complete.cases(genelist2),]
  
  g <- goana(EntrezIDs)
  
  g_bp <- g %>%
    filter(Ont == "BP")
  topGO_bp <- topGO(g_bp) %>%
    mutate(log10_p = -log10(P.DE),module=module,color="red") %>%
    arrange(desc(log10_p))
  
  g_mf <- g %>%
    filter(Ont == "MF")
  topGO_mf <- topGO(g_mf) %>%
    mutate(log10_p = -log10(P.DE),module=module,color="blue") %>%
    arrange(desc(log10_p))
  
  topGO_all <- rbind(topGO_bp,topGO_mf) %>%
                       arrange(as.numeric(log10_p)) %>%
                       dplyr::mutate(roworder = row_number())
  
  p <- ggplot(topGO_all,aes(x=reorder(Term,roworder),y=as.numeric(log10_p),fill=module,color=color)) +
    geom_bar(stat="identity") + coord_flip() + scale_fill_identity() + scale_color_identity() + facet_wrap(~Ont,scales="free") + 
    ggtitle(module) +
    labs(x="Go Term", y = "-log10(p-value)") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.title = element_text(size = rel(2.2), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
        axis.title = element_text(size = rel(1.8), face="bold"),
        axis.text.y = element_text(size = rel(1.4), face="bold"),
        axis.text.x = element_text(size = rel(1.4), face="bold",angle=90,vjust = 0.5, hjust=1),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
        legend.position="none",
        legend.title=element_blank(),
        legend.text=element_blank(),
        strip.text.x = element_text(size = rel(2.2)))
  p
  
#ggsave(plot = print(p),paste("WGCNA/",module,"_uc110_bar.png",sep=""),height=5,width=20)
}
  
  
  
  #GOenr <- GOenrichmentAnalysis(moduleColors, allLLIDs, organism = "mouse", nBestP = 10);
}



```

```{r umap,eval=FALSE}

gene_primemodule <- geneModuleMembership %>%
  mutate(primemodule = colnames(geneModuleMembership)[apply(geneModuleMembership,1,which.max)]) %>%
  dplyr::select(primemodule) %>%
  dplyr::mutate(genenames = row.names(geneModuleMembership))

umap_modules <- umap(geneModuleMembership)

umap_data <- as.data.frame(umap_modules$layout)

umap_data <- umap_data %>%
  dplyr::mutate(genenames = row.names(umap_data)) %>%
  dplyr::left_join(gene_primemodule,by = "genenames") %>%
  dplyr::mutate(modulecolor = str_remove(primemodule,"MM"))

p <- ggplot(umap_data,aes(x = V1, y = V2, color = modulecolor)) +
  geom_point() + 
  scale_color_identity() +
  theme(theme(plot.title = element_blank(),
              axis.title = element_text(size = rel(2.2), face="bold"),
              axis.text = element_text(size = rel(2.2), face="bold"),
              #panel.grid = element_line(color = "lightgray",size = 0.75),
panel.background = element_blank(), axis.line = element_line(colour = "black"),legend.position="top",legend.title=element_blank(),
legend.text=element_text(size=rel(2.2))))

p

columnmaxes <- apply(geneModuleMembership,2,max)

```

```{r,eval=FALSE}

TOM1 <- as.data.frame(table(TOM))

power=6 
color1=colorDynamicTOM 
restGenes=(color1!="grey") 
diss1=adjacency(datExpr[,restGenes],power=6) 
hier1=hclust(as.dist(diss1),method="average") 
diag(diss1)=NA; sizeGrWindow(7,7) 

TOMplot(diss1^4,hier1,as.character(color1[restGenes]), main="Adjacencyheatmapplot,modulegenes")

net <- net

net <- as_tibble(net$color, rownames = "genes") %>%
  dplyr::rename(module = value) %>%
  mutate(geneorder = !!(net$dendrograms[[1]]$order))

```


