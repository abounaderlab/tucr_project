---
title: 'Uncovering a role for transcribed ultra-conserved regions as long non-coding RNAs in gliomas'
author: "Myron Gibert Jr"
date: "January 27, 2020"
output: pdf_document
toc: true
---

```{r refseq}

refseq <- read.table("BEDFiles/refseq.bed",header=TRUE) %>%
  dplyr::select(chrom,"start"=txStart,"end"=txEnd,strand,"id"=name2,annot,tag) 

CHESSgenes <- read.table("BEDFiles/CHESSgenes.bed",header=FALSE) %>%
  dplyr::select("chrom"=V1,"start"=V2,"end"=V3,"strand"=V4,"id"=V5,"annot"=V6,"tag"=V7)

mergedref <- rbind(refseq,CHESSgenes) %>%
  group_by(id,strand) %>%
  mutate(
    trustart = min(start,na.rm=TRUE),
    truend = max(end,na.rm=TRUE),
    truannot=(
      ifelse(annot=="protein_coding",4,
      ifelse(annot=="lncRNA",3,
      ifelse(annot=="antisense_RNA",2,
      ifelse(annot=="misc_RNA",1,0))))),
    trufilter=max(truannot,na.rm=TRUE)
  ) %>%
  ungroup() %>%
  filter(truannot==trufilter) %>%
  dplyr::select(chrom,"start"=trustart,"end"=truend,strand,id,annot,tag) %>%
  distinct() %>%
  mutate(id2 = paste(id,"___",chrom,strand,":",start,"_",end,sep=""),
    antisense = str_detect(id, "-AS"),
         lncRNA = str_detect(id, "LINC"),
    dot = ifelse(
    tag == "refseq" & annot == "misc_RNA" & antisense == TRUE,"antisense_RNA",
    ifelse(tag == "refseq" & annot == "misc_RNA" & lncRNA ==  TRUE,"lncRNA",
    as.character(annot)))) %>%
  dplyr::select(chrom,start,end,strand,"id"=id2,"annot"=dot) %>%
  distinct() %>%
  filter(!grepl("_",chrom)) %>%
  group_by(id,chrom,start,end) %>%
  mutate(n=n()) %>%
  ungroup() %>%
  filter(!(n>1 & annot == "misc_RNA")) %>%
  dplyr::select(-n)

write_delim(mergedref,"BEDFiles/allgenes.bed",delim="\t")

```


*https://www.nature.com/articles/sdata201861

This methodology is less relevant to GBM and LGG because there are only 5 normals in these datasets to compare GTex to.

# Abstract

Gliomas represent the most common brain tumors.  Particularly, glioblastoma (GBM) is the most common and most deadly malignant brain tumor. Most glioma research has focused on protein-coding genes and much less on the non-coding transcripts that make up 98% of cellular RNA. Transcribed Ultra-Conserved Regions (TUCRs) represent an understudied class of molecules that are found conserved across multiple species. These transcripts are highly resistant to variation and are commonly deregulated in cancer, suggesting regulatory and functional importance.  Intergenic TUCRs specifically represent potential novel protein coding and non-coding transcripts, as they do not overlap with known genes.  We performed the first analysis of TUCRs in glioblastoma and low grade glioma (LGG).  Previously established methodologies were used to annotate TUCRs and confirm that they are transcribed.  Then, differentially expressed (DE) TUCRs were identified in GBM (n = 197) and LGG (n = 149), along with those who correlate with survival in GBM (n = 36) and LGG (n = 167).  TUCRs were then scored by their absolute and relative expression in GBM and LGG, frequency of deregulation, and correlation with survival.  These scores provide a means for prioritizing TUCRs for future experiments. Using a GBM and LGG RNA-Seq data to generate a list of co-regulated genes, a guilt-by-association analysis was performed to determine what biological processes and molecular functions may be shared by TUCRs and their co-regulated genes.  Lastly, as TUCRs represent fractions of larger host transcripts, we sought to identify and characterize the parent transcripts of intergenic TUCRs.  We propose that these host transcripts represent novel genes, with the TUCR itself serving as a component of these transcripts.  The results of this study provide an insight into several exciting future research directions.

# Introduction

Gliomas account for approximately 80% of all brain tumors.  In particular, glioblastoma (GBM) accounts for about half of all primary brain and central nervous system cancers.  It is also one of the most-deadly cancers. One-, five-, and ten-year survival rates for patients with GBM are 37 percent, 5%, and 3%, respectively.  Although there has been extensive research on protein coding genes and pathways in GBM and low grade gliomas (LGG), the current standard of care involves surgical resection and radiation, with limited targeted therapies.

Many targeted therapies in the context of GBM, LGG, and other malignancies focus on protein-coding genes.  And yet, these genes make up only a small portion of the transcriptome; ~90% of the genome is transcribed, but only ~2 percent of the transcriptome is then translated. The remainder of the transcriptome is represented by non-coding elements that can serve key regulatory roles. Of these elements, long non-coding RNAs (lncRNAs) have recently been determined to serve as important regulators of malignancy and potential therapeutic targets in cancer. These lncRNAs are transcribed RNA molecules that contain greater than 200 nucleotides but typically lack significant protein coding capabilities. 

There are several genetic regions that are “ultra-conserved” across species (UCR).  From these regions, Transcribed ultra-conserved regions (TUCRs) represent 481 unique transcribed regions of the genome that are greater than 200 base pairs in length and are highly conserved across multiple species, including human, mouse (100%), rat (100%), dog (98%), and chicken (95%) genomes. Due to their size (>200 nt) and lack of known associated protein products, TUCRs may function as lncRNAs.  The existence of highly conserved lncRNAs is significant, as lncRNAs are typically poorly conserved as a class of molecules.  TUCRs are highly resistant to variation, with the 106,767 conserved bases overlapping with as few as six canonical single nucleotide polymorphisms (SNPs).  Their expression is commonly deregulated in cancer.

Because of this, it is believed that these TUCRs may serve crucial regulatory roles in cancer. The non-coding RNA field is a growing one.  While only a single lncRNA paper was published in 2007, that number has exploded to 1342 publications by the year 2016.  Despite this explosion of interest in lncRNAs, very little is known of TUCRs.  In particular, the literature elucidating the expression, functions and mechanisms of action of TUCRs in GBM and/or LGG is nonexistent. Studying them therefore represents an untouched avenue for understanding novel oncogenic mechanisms and discovering new biomarkers and therapeutic targets for these diseases.

Here, we utilize contemporary and novel bioinformatics techniques to perform the first characterization of TUCR expression, function, and mechanism of action in GBM and LGG.  First, TUCRs were annotated and validated to confirm that annotations from 2010 are consistent with more recent databases.  Then, programming tools were used to identify TUCRs that are differentially expressed in GBM and LGG tissues.  TUCRs that are correlated with GBM and LGG patient survival were also identified.  Then, a guilt-by-association analysis was performed to predict TUCR functional roles using coregulated genes.  Lastly, we predict that intergenic TUCRs may represent markers for novel genes. To test this hypothesis, de novo transcript reassembly was used to identify transcripts present in RNA-Seq datasets in a genome agnostic manner.  Selection criteria were then used to identify potentially novel genes from the resulting dataset.

## Setup

### Set parameters

This initial section is used to set the dependent variables that are used for this analysis. 

The following variables can be set:
* countfilename is the name of the RNA-Seq feature count file that is generated in the "Generating count tables for survival and differential expression" section.  This can be any tab-delimited text file where the row names are the genes, the column names are the samples, and the cells are the generated counts.  This table is used for both survival and differential expression analyses.
* makekpmplots is a logical vector.  When set to TRUE, the script will generate Kaplan-Meier survival plots for each gene in the counts file.
* makerpkmoxplots is also a logical vector.  When set to TRUE, the script will generate reads per kilobase million boxplots for each gene, showing median RPKM, mean RPKM (red dot), and additional summary information. This is used to determine to what extent a gene is expressed across all samples
* repel is also a logical vector.  When set to true, the volcano summary plot for RNA-Seq expression data will contain labels for a given set of genes specified in the "Generating volcano plot to visualize DE genes"
* outputdir is a character variable containing the "output directory", or the location where all output files will go. This can be any characters enclosed in quotations marks (ex. "Outputs"). Set to "Outputs" to use the default outputs folder
* useintermediate is a logical vector.  When set to TRUE, the analysis will use a pregenerated gene correlation matrix for the guilt by association analysis.  Unless there is a specific reason to generate a new matrix (VERY memory intensive), this variable should be set to TRUE.
* deleteoutputs is a logical vector that should only be set to TURE or FALSE.  When set to true, the output directory will be repopulated after every program run.  If set to false, the program will only run if the output directory does not already exist in the working directory, to prevent the data from being overwritten.

### Install required programs

```{r setup, message = FALSE, warning=FALSE}
knitr::opts_chunk$set(
	#eval = FALSE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)

if (!require("jsonlite")) install.packages("jsonlite")
library("jsonlite")

if (!require("tidyjson")) install.packages("tidyjson")
library("tidyjson")

if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse")

if (!require("ggplot2")) install.packages("ggplot2")
library("ggplot2")

if (!require("ggforce")) install.packages("ggforce")
library("ggforce")

if (!require("ggrepel")) install.packages("ggrepel")
library("ggrepel")

if (!require("ggfortify")) install.packages("ggfortify")
library("ggfortify")

if (!require("ggdendro")) install.packages("ggdendro")
library("ggdendro")

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
if (!requireNamespace("DESeq2", quietly = TRUE))BiocManager::install("DESeq2")
library("DESeq2")

if (!require("survival")) install.packages("survival")
library("survival")

if (!require("broom")) install.packages("broom")
library("broom")

if (!requireNamespace("limma", quietly = TRUE))BiocManager::install("limma")
library("limma")

if (!require("Tmisc")) install.packages("Tmisc")
library("Tmisc")

if (!require("survminer")) install.packages("survminer")
library("survminer")

if (!require("corrr")) install.packages("corrr")
library("corrr")

if (!require("here")) install.packages("here")
library("here")

if (!require("lessR")) install.packages("lessR")
library("lessR")

if (!require("splitstackshape")) install.packages("splitstackshape")
library(splitstackshape)

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

if (!require('org.Hs.eg.db')) BiocManager::install('org.Hs.eg.db')
library(org.Hs.eg.db)

if (!require('GO.db')) BiocManager::install('GO.db')
library(GO.db)

if (!require('limma')) BiocManager::install('limma')
library(limma)

if (!require("ggthemes")) install.packages('ggthemes', dependencies = TRUE)
library(ggthemes)

if (!require("gplots")) 
install.packages("gplots")
library(gplots)

if (!require("heatmap.plus")) 
install.packages("heatmap.plus")
library(heatmap.plus)

if (!require("RColorBrewer")) 
install.packages("RColorBrewer")
library(RColorBrewer)

###

disease <- "GBM"

normal <- "cortex"

outputdir <- "Outputs_GBM_cortex"

filterannot <- "TUCR"

makeSNP <- TRUE

makeannotate <- TRUE

makelncRNA <- TRUE

makeBEDs <- TRUE

makeDE <- TRUE

RPKmethod <- "RPKM"

repel <- TRUE

makesurvival <- TRUE

makekpmplots <- TRUE

makeSuvivalplots <- TRUE 

makeRPKboxplots <- TRUE

makecorrelations <- TRUE

useintermediate <- TRUE

makeGOterms <- TRUE

```

```{r tinytex, include=FALSE}
## INSTALLING LATEX FOR RMARKDOWN

#RMarkdown requires LaTex to create pdf documents as an output. More information can be found [here](https://bookdown.org/yihui/rmarkdown/pdf-document.html). Alternatively, output can be set to "html_document" or "word_document". End users may install LaTex by setting the "wanttinytex" variable to FALSE and running the following script:

#Install tinytex to let RMarkdown create a pdf document? Default: wanttinytex <- FALSE
wanttinytex <- TRUE

if(tinytex:::is_tinytex()==FALSE && wanttinytex == TRUE){
if (!require("tinytex")) install.packages("tinytex")
tinytex::install_tinytex()
}
```

### Create output directory

This script checks to see if the defined output directory already exists.  If it doesn't exist, it will create the directory.

```{r outputs}
if(!dir.exists(outputdir)){
  dir.create(outputdir)
}

t_countfile <- paste(disease,"mergedcounts.txt",sep="_")

n_countfile <- paste(normal,"mergedcounts.txt",sep="_")

t_metadatafile <- paste(disease,"tcga_metadata.csv",sep="_")

n_metadatafile <- paste(normal,"gtex_metadata.csv",sep="_")

t_seqdepthfile <- paste(disease,"seqdepth_counts.csv",sep="_")

n_seqdepthfile <- paste(normal,"seqdepth_counts.csv",sep="_")

intermediatefile <- paste(disease,"matrixintermediate.Rdata",sep="_")

```

# Section 1: Transcribed Ultra-conserved Regions (TUCRs) are a broad class of molecules

##Results

TUCRs are a broad class of molecules spanning the entire human genome.  Many TUCRs are contained within coding and non-coding transcripts.  Some TUCRs are exonic and are contained within an exon of the “host” gene (Figure 1A).  Others are contained within an intron instead (Figure 1B).  Some TUCRs straddle a region that spans exonic and intronic regions of the host gene (intronic/exonic) (Figure 1C), and others are not contained within a known genetic element at all (intergenic) (Figure 1D). Each of the 481 TUCRs were previously annotated in 2010.  Here, we provide an updated annotation that includes scientific discoveries made in the intervening decade (Figure 1E).  Through manual annotation, we have identified 46 exonic, 150 intronic, 67 intronic/exonic, and 218 intergenic TUCRs.  The full list of these annotations is available as a supplement (Supplementary Table 1)

It is critical that we confirm that TUCRs are transcribed to an extent that is comparable to known protein and non-coding genes.  Much of the genome is transcribed, but a relatively small fraction represents functional transcripts and genes.  The rest is considered transcriptional “noise”.  We sought to confirm that TUCRs do not represent transcriptional noise, but functional genomic units.

To analyze the transcription of TUCRs, we evaluated the local chromatin landscape and compared it to that of protein coding genes, non-coding RNAs, and randomized control genomic intervals.  We specifically wanted to focus on H3K4me3, a marker for open chromatin, and RNA Pol.II, which is involved in the transcription of many non-coding RNAs.  Using GBM U87 CHIP-Seq data, we performed two separate analyses of epigenetic density.  

First, publicly available U87 H3K4me3 and RNA Pol.II CHIP-Seq data were downloaded and processed. Then, we identified the nearest epigenetic marker to each TUCR and compared these results to randomized control intervals of a similar length, protein coding genes, and various non-coding elements. These analyses were performed using H3K4me3 (Figure 2A) and RNA Pol.II (Figure 2B) binding sites. Then, we considered the density of H3K4me3 and RNA Pol.II binding within a 10 kilobase (kb) window up- and downstream of each class of gene (Control, TUCR, lncRNA, and mRNA).  Fisher’s exact test was used to confirm that the chromatin landscape is more significantly enriched for H3K4me3 and RNA Pol.II than a random control interval and is more consistent with coding and non-coding genes. (Figure 2C) 

## Methodology

### Generate Figure 1E for TUCR annotation

Figures 1A-1D were manually generated using Microsoft Powerpoint. TUCRs were then manually annotated, creating the "hg38.ultraconserved.bed" file provided in this repository.  As previously mentioned, we have identified 46 exonic, 150 intronic, 67 intronic/exonic, and 218 intergenic TUCRs. Figure 1E was generated using GGPlot2.

In the following code chunk, if the variable "makeannotate" is set to true, all subsequent lines will be run.  The chunk then reads in the "hg38.ultraconserved.bed" file and compiles the relevant information into a proportion ring chart as depicted in Figure 1E. The results are placed in the output directory as defined by the variable outputdir.

```{r Section1_annotation}
if(makeannotate == TRUE){
#Read in Data
tucr_annot <- read.table("BEDFiles/hg38.ultraconserved.bed") %>%
  dplyr::select("row" = V5, "annot" = V7)

#Prepare data for visualization
plot_annotation <- tucr_annot %>% 
  group_by(annot) %>%
  summarise(count = n()) %>%
  mutate(percent = count/sum(count)) %>%
  arrange(desc(count)) %>%
#Determine label positions
  mutate(lab.ypos = cumsum(count) - 0.5*count)

#Set factor levels
names(plot_annotation)[names(plot_annotation) == 'annot'] <- 
  'Annotation'

#Create Chart
p <- ggplot(plot_annotation, aes(x=2,y=count,fill=Annotation))          + 
  geom_bar(
    stat="identity",colour="black", 
    width = 1)                                                          +
  geom_text(
    aes(y = lab.ypos, label = count), 
    color = "black")                                                    + 
  coord_polar("y", start=0)                                             + 
  scale_fill_manual(values=c("#F8766D","#00BFC4","#7CAE00","#C77CFF"))  + 
  ggtitle(paste("TUCR Genomic Location"))                               + 
  theme(
    plot.title = element_text(size=rel(1.0),
    face="bold",hjust = 0.5,vjust=-10),
    legend.title.align=0.5, 
    axis.title = element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.line=element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.ticks=element_blank(),
    panel.background = element_blank())                                 + 
  xlim(0.5, 2.5)

p

#Save Chart to output directory
ggsave(file=paste(outputdir,"/",disease,"_tucr_annotation.png",sep=""),
       plot = print(p), 
       width = 5, 
       height = 5, 
       dpi = 300)
}
```

## Acquiring SNPs

Bejerano et al, 2004, reported that TUCRs are resistant to variation. We sought to update our understanding of TUCR variation using the latest resources.  The following code chunk using bash scripting to download and decompress the most recent database for known SNPs (as of 2021) by chromosome.

```{bash Section1_SNPget, eval = FALSE}
mkdir SNPs

cd SNPs

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_1.bed.gz
gunzip bed_chr_1.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_10.bed.gz
gunzip bed_chr_10.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_11.bed.gz
gunzip bed_chr_11.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_13.bed.gz
gunzip bed_chr_13.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_12.bed.gz
gunzip bed_chr_12.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_14.bed.gz
gunzip bed_chr_14.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_15.bed.gz
gunzip bed_chr_15.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_16.bed.gz
gunzip bed_chr_16.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_17.bed.gz
gunzip bed_chr_17.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_18.bed.gz
gunzip bed_chr_18.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_19.bed.gz
gunzip bed_chr_19.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_2.bed.gz
gunzip bed_chr_2.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_20.bed.gz
gunzip bed_chr_20.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_21.bed.gz
gunzip bed_chr_21.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_22.bed.gz
gunzip bed_chr_22.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_3.bed.gz
gunzip bed_chr_3.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_4.bed.gz
gunzip bed_chr_4.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_5.bed.gz
gunzip bed_chr_5.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_6.bed.gz
gunzip bed_chr_6.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_7.bed.gz
gunzip bed_chr_7.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_8.bed.gz
gunzip bed_chr_8.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_9.bed.gz
gunzip bed_chr_9.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_X.bed.gz
gunzip bed_chr_X.bed.gz

wget ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/BED/bed_chr_Y.bed.gz
gunzip bed_chr_Y.bed.gz

```

### Getting SNP intersects for genes

After downloading and unzipping the SNP genomic location files, we then use bedtools to identify and report all SNPs that overlap with TUCR bases/nucleotides.  

The following chunk contains a for-loop that does this for all bed files in the directory created during the previous step for TUCRs.  These were then compared to results for protein coding genes, long non-coding RNAs, antisense RNAs, and miscellaneous RNAs to determine comparable resistance to variation.

```{bash Section1_SNPintersect, eval = FALSE}

mkdir SNPanalysis/

### TUCRs ###
for bed in RNASEQ-PROCESSED/BEDFiles/chr*
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
echo $name

intersectBed -a BEDFiles/hg38.ultraConserved.bed -b $bed -wa -wb > $name.TUCR.SNPs.bed

done

cat *.TUCR.SNPs.bed > SNPanalysis/merged_TUCR_SNPs.bed

rm *TUCR.SNPs.bed

### coding genes ###

awk -F "\t" '{ if($7 == "protein_coding") { print } }' CHESSgenes.bed > CHESScoding.bed

for bed in RNASEQ-PROCESSED/BEDFiles/chr*
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
echo $name

intersectBed -a CHESScoding.bed -b $bed -wa -wb > $name.coding.SNPs.bed

done

cat *coding.SNPs.bed > SNPanalysis/merged_coding_SNPs.bed

rm *coding.SNPs.bed
rm CHESScoding.bed

### lncRNAs ###

awk -F "\t" '{ if($7 == "lncRNA") { print } }' CHESSgenes.bed > CHESSlncRNA.bed

for bed in RNASEQ-PROCESSED/BEDFiles/chr*
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
echo $name

intersectBed -a CHESSlncRNA.bed -b $bed -wa -wb > $name.lncRNA.SNPs.bed

done

cat *lncRNA.SNPs.bed > SNPanalysis/merged_lncRNA_SNPs.bed

rm *lncRNA.SNPs.bed
rm *CHESSlncRNA.bed

### antisense RNAs ###

awk -F "\t" '{ if($7 == "antisense_RNA") { print } }' CHESSgenes.bed > CHESSantisense.bed

for bed in RNASEQ-PROCESSED/BEDFiles/chr*
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
echo $name

intersectBed -a CHESSantisense.bed -b $bed -wa -wb > $name.antisense.SNPs.bed

done

cat *antisense.SNPs.bed > SNPanalysis/merged_antisense_SNPs.bed

rm *antisense.SNPs.bed
rm CHESSantisense.bed

### miscRNAs ###

awk -F "\t" '{ if($7 == "antisense_RNA") { print } }' CHESSgenes.bed > CHESSmisc.bed

for bed in RNASEQ-PROCESSED/BEDFiles/chr*
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
echo $name

intersectBed -a CHESSmisc.bed -b $bed -wa -wb > $name.misc.SNPs.bed

done

cat *misc.SNPs.bed > SNPanalysis/merged_misc_SNPs.bed

rm *misc.SNPs.bed
rm CHESSmisc.bed
```

### Count intersecting SNPs

This file counts the number of rows in each file.  Each row represents a single SNP, thus providing a count of all overlapping SNPs by annotation category.

```{bash Section1_SNPcount, eval = FALSE}

wc -l merged_TUCR_SNPs.bed

wc -l merged_coding_SNPs.bed

wc -l merged_lncRNA_SNPs.bed

wc -l merged_antisense_SNPs.bed

wc -l merged_misc_SNPs.bed

```

### Generate SNP proportion graph

```{r Section1_SNPgraph}
if(makeSNP == TRUE){
tucr_SNP <- read.csv("tucr_SNPs.csv")

p <- ggplot(tucr_SNP, aes(x=reorder(annot,order),y=proportion*100,fill=reorder(annot,order))) + 
  geom_bar(stat="identity", width = 0.7, 
    color = "black") + 
  geom_text(aes(label=round(proportion*100,3)), vjust=1.6, color="black", size=7) + 
  scale_fill_manual(values=c("red3","green4","blue3","deeppink","yellow2","orange2")) + 
  ggtitle(paste("TUCRs are less susceptible to variation than other genes")) + 
  xlab("gene annotation") + 
  ylab("Percent variant nucleotides (SNPs)") + 
  theme(
    plot.title = element_text(size=rel(1.0), face="bold",hjust = 0.5),
    axis.title = element_text(size = rel(1.0), face="bold"),
    legend.title = element_blank(),
    legend.position = "none",
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    panel.background = element_blank(), 
    axis.line = element_line(colour = "black"))

ggsave(file=paste(outputdir,"/",disease,"_SNPGraph.png",sep=""),
       plot = print(p),
       width = 5, 
       height = 6, 
       dpi = 300)
}
```

### Aquire the data using the SRA toolkit

```{bash Section1_SRAToolkit, eval = FALSE}

#using SRA Toolkit version 2.10.5

#Transcriptional Amplification in Tumor Cells with Elevated c-Myc
#https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE36354


#CHIP-Seq U87-H3K4me3 

prefetch SRR444442

#CHIP-Seq U87-RNAPolII

prefetch SRR444478

```

### Generate fastq files

```{bash Section1_fastq, eval = FALSE}

for sra in SRR*
do
echo $sra
fastq-dump $sra
done

```

### Build hg38 genome

```{bash Section1_build_hg38genome, eval = FALSE}

wget https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz
gunzip hg38.fa.gz

#Rivanna only.  Skip otherwise.
module load gcc/7.1.0
module load bowtie2/2.2.9

bowtie2-build hg38.fa hg38

```

### Align fastq files to reference genome

```{bash Section1_sam, eval = FALSE}

for fq in *.fastq
do
name=$(echo $fq | awk -F".fastq" '{print $1}')
echo $name
bowtie2 -x hg38 -U $fq -S $name.sam
done

```

### Convert sam to bam

```{bash Section1_bam, eval = FALSE}

for sam in *.sam
do
name=$(echo $sam | awk -F".sam" '{print $1}')
echo $name
samtools view -b $sam | samtools sort -o $name.bam
done
rm *sam

```

### Index bam files

```{bash Section1_index, eval = FALSE}

for bam in *bam
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools index $bam
done

```

### Convert to bed

I got this methodology from [here](https://github.com/stevekm/reference-annotations/blob/master/Makefile) since my other methods were not working.

```{bash Section1_callpeaks, eval = FALSE}

macs2 callpeak -t SRR444442.bam -n SRR444442 -g hs
macs2 callpeak -t SRR444478.bam -n SRR444478 -g hs

wc -l *Peak

cat SRR444442_peaks.narrowPeak | cut -f 1-4 | grep -v KI | grep -v MT | grep -v GL | grep -v JH | grep -v KB | grep -v chrM > h3k4me3.bed
cat SRR444478_peaks.narrowPeak | cut -f 1-4 | grep -v KI | grep -v MT | grep -v GL | grep -v JH | grep -v KB | grep -v chrM > pol2.bed

```

### Download Genome Annotation file

```{bash Section1_referenceFile, eval = FALSE}

wget ftp://ftp.ensembl.org/pub/release-90/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz

gunzip Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz

samtools faidx Homo_sapiens.GRCh38.dna.primary_assembly.fa

awk -v OFS='\t' {'print $1,$2'} Homo_sapiens.GRCh38.dna.primary_assembly.fa.fai > hg38_genomeFile.txt

cat hg38_genomeFile.txt | grep -v KI | grep -v MT | grep -v GL | sed -e "s/^/chr/g" > temp

mv temp hg38_genomeFile.txt

```

### Generate Random Intervals and sort all files

```{bash Section1_sortbed, eval = FALSE}

bedtools shuffle -i pol2.bed -g hg38_genomeFile.txt > pol2shuff.bed
bedtools sort -i pol2shuff.bed > pol2shuff.sort.bed

bedtools shuffle -i h3k4me3.bed -g hg38_genomeFile.txt > h3k4me3shuff.bed
bedtools sort -i h3k4me3shuff.bed > h3k4me3shuff.sort.bed

bedtools sort -i pol2.bed > pol2.sort.bed

bedtools sort -i h3k4me3.bed > h3k4me3.sort.bed

bedtools sort -i hg38.ultraConserved.bed > hg38.ultraConserved.sort.bed

bedtools sort -i TUCR_intergenic.bed > TUCR_intergenic.sort.bed

bedtools sort -i CHESScoding.bed > CHESScoding.sort.bed

bedtools sort -i CHESSlncRNA.bed > CHESSlncRNA.sort.bed

bedtools sort -i CHESSantisense.bed > CHESSantisense.sort.bed

bedtools sort -i CHESSmisc.bed > CHESSmisc.sort.bed

```

### Find closest Pol.II binding site using bedtools closest

```{bash Section1_closest_PolII, eval = FALSE}

bedtools closest -a hg38.ultraConserved.sort.bed -b pol2shuff.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_random_intervals_output.bed

bedtools closest -a hg38.ultraConserved.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_tucrs_output.bed

bedtools closest -a TUCR_intergenic.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_intergenic_tucrs_output.bed

bedtools closest -a CHESScoding.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_coding_output.bed

bedtools closest -a CHESSlncRNA.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_lncRNA_output.bed

bedtools closest -a CHESSantisense..sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_antisense_output.bed

bedtools closest -a CHESSmisc.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt -d > closest_pol2_misc_output.bed

```

### Find closest H3K4me3 binding site using bedtools closest

```{bash Section1_closest_h3k4me3, eval = FALSE}

bedtools closest -a hg38.ultraConserved.sort.bed -b h3k4me3shuff.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_random_intervals_output.bed

bedtools closest -a hg38.ultraConserved.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_tucrs_output.bed

bedtools closest -a TUCR_intergenic.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_intergenic_tucrs_output.bed

bedtools closest -a CHESScoding.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_coding_output.bed

bedtools closest -a CHESSlncRNA.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_lncRNA_output.bed

bedtools closest -a CHESSantisense.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_antisense_output.bed

bedtools closest -a CHESSmisc.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt -d > closest_h3k4me3_misc_output.bed

```

### Graphing closest H3K4me3 marks

```{r CHIPgraphs-h3k4me3}

filenames.H3K4me3 <- list.files("./closest_bed/H3K4me3/")

mastertable.H3k4me3 <- data.frame(matrix(ncol=11,nrow=0, dimnames=list(NULL,c("chromosome.gene","start.gene","end.gene","gene","strand","annot",
"chromosome.H3K4me3","start.H3K4me3","end.H3K4me3","H3K4me3","dist"))))

i = 1
for(i in 1:length(filenames.H3K4me3)){
  print(i)
  df <- read.table(paste("./closest_bed/H3K4me3/",filenames.H3K4me3[i],sep=""))
  colnames(df) <- colnames(mastertable.H3k4me3)
  mastertable.H3k4me3 <- rbind(mastertable.H3k4me3,df)
}

mastertable.H3k4me3.sum <- mastertable.H3k4me3 %>%
  mutate(interval = ifelse(dist<500, 500,
                          ifelse(dist<1000, 1000,
                          ifelse(dist<1500, 1500,
                          ifelse(dist<2000, 2000,
                          ifelse(dist<2500, 2500,
                          ifelse(dist<3000, 3000,
                          ifelse(dist<3500, 3500,
                          ifelse(dist<4000, 4000,
                          ifelse(dist<4500, 4500,
                          ifelse(dist<5000, 5000,
                          ifelse(dist<5500, 5500,
                          ifelse(dist<6000, 6000,
                          ifelse(dist<6500, 6500,
                          ifelse(dist<7000, 7000,
                          ifelse(dist<7500, 7500,
                          ifelse(dist<8000, 8000,
                          ifelse(dist<8500, 8500,
                          ifelse(dist<9000, 9000,
                          ifelse(dist<9500, 9500,
                          ifelse(dist<10000, 10000,10500))))))))))))))))))))) %>%
  filter(interval != 10500) %>%
  mutate(order = ifelse(annot=="protein_coding", 1,
                          ifelse(annot=="lncRNA", 2,
                          ifelse(annot=="TUCR", 3,
                          ifelse(annot=="intergenic_TUCR", 7,
                          ifelse(annot=="antisense_RNA", 4,
                          ifelse(annot=="misc_RNA", 5,
                          ifelse(annot=="random", 6,0
                          )))))))) %>%
  mutate(annot = fct_reorder(annot,order)) %>%
  group_by(annot,interval,order) %>%
  summarise(total = n()) %>%
  ungroup() %>%
  group_by(annot) %>%
  mutate(div = sum(total)) %>%
  mutate(prop = total/div) %>%
  mutate(log10 = log10(total)) %>%
  mutate(log2 = log2(total)) %>%
  arrange(order)

p <- ggplot(mastertable.H3k4me3.sum, aes(x=interval,y=log2,fill=annot,order=order)) + 
  geom_bar(stat="identity", 
    color = "black")                                                      + 
  scale_fill_manual(values = c("red3","green4","blue3","deeppink","yellow2","orange2")) +
  xlab("distance (nt)")                                           + 
  ylab("log(density)")                                           + 
  theme(
    plot.title = element_blank(),
    axis.title = element_text(
      size = rel(1.25), 
      face="bold"),
    axis.text.x = element_text(
      angle = -90, 
      size = 10),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    panel.background = element_blank(), 
    axis.line = element_line(
      colour = "black"))

ggsave(
    file=paste(outputdir,"/",disease,"_tucr_dist_h3k4me3.png",sep=""),
    plot = print(p),
    width = 10, 
    height = 5, 
    dpi = 300) 

```

### Graph closest RNA Pol.II Binding Sites

Have to add strand labels to TUCR output.  Have to change random file "annot" column to "random".

```{r CHIPgraphs-pol2}

filenames.pol2 <- list.files("./closest_bed/pol2/")

mastertable.pol2 <- data.frame(matrix(ncol=11,nrow=0, dimnames=list(NULL,                  c("chromosome.gene","start.gene","end.gene","gene","strand","annot",
"chromosome.pol2","start.pol2","end.pol2","pol2","dist"))))

i = 1
for(i in 1:length(filenames.pol2)){
  print(i)
  df <- read.table(paste("./closest_bed/pol2/",filenames.pol2[i],sep=""))
  colnames(df) <- colnames(mastertable.pol2)
  mastertable.pol2 <- rbind(mastertable.pol2,df)
}

mastertable.pol2.sum <- mastertable.pol2 %>%
  mutate(interval = ifelse(dist<500, 500,
                          ifelse(dist<1000, 1000,
                          ifelse(dist<1500, 1500,
                          ifelse(dist<2000, 2000,
                          ifelse(dist<2500, 2500,
                          ifelse(dist<3000, 3000,
                          ifelse(dist<3500, 3500,
                          ifelse(dist<4000, 4000,
                          ifelse(dist<4500, 4500,
                          ifelse(dist<5000, 5000,
                          ifelse(dist<5500, 5500,
                          ifelse(dist<6000, 6000,
                          ifelse(dist<6500, 6500,
                          ifelse(dist<7000, 7000,
                          ifelse(dist<7500, 7500,
                          ifelse(dist<8000, 8000,
                          ifelse(dist<8500, 8500,
                          ifelse(dist<9000, 9000,
                          ifelse(dist<9500, 9500,
                          ifelse(dist<10000, 10000,10500))))))))))))))))))))) %>%
  filter(interval != 10500) %>%
  mutate(order = ifelse(annot=="protein_coding", 1,
                          ifelse(annot=="lncRNA", 2,
                          ifelse(annot=="TUCR", 3,
                          ifelse(annot=="intergenic_TUCR", 7,
                          ifelse(annot=="antisense_RNA", 4,
                          ifelse(annot=="misc_RNA", 5,
                          ifelse(annot=="random", 6,0
                          )))))))) %>%
  mutate(annot = fct_reorder(annot,order)) %>%
  group_by(annot,interval,order) %>%
  summarise(total = n()) %>%
  ungroup() %>%
  group_by(annot) %>%
  mutate(div = sum(total)) %>%
  mutate(prop = total/div) %>%
  mutate(log10 = log10(total)) %>%
  mutate(log2 = log2(total)) %>%
  arrange(order)

p <- ggplot(mastertable.pol2.sum, aes(x=interval,y=log2,fill=annot,order=order)) + 
  geom_bar(stat="identity",
    color = "black")                                                      + 
  scale_fill_manual(values = c("red3","green4","blue3","deeppink","yellow2","orange2")) +
  xlab("distance (nt)")                                           + 
  ylab("log(density)")                                           + 
  theme(
    plot.title = element_blank(),
    axis.title = element_text(
      size = rel(1.25), 
      face="bold"),
    axis.text.x = element_text(
      angle = -90, 
      size = 10),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    panel.background = element_blank(), 
    axis.line = element_line(
      colour = "black"))

ggsave(
    file=paste(outputdir,"/",disease,"_tucr_dist_pol2.png",sep=""),
    plot = print(p),
    width = 10, 
    height = 5, 
    dpi = 300) 

```

### Generate TUCR "Windows"

```{bash Section1_slop, results="hide", eval = FALSE}

bedtools slop -b 10000 -i random_intervals.bed -g hg38_genomeFile.txt > random_pm10kb.bed

bedtools slop -b 10000 -i hg38.ultraConserved.sort.bed -g hg38_genomeFile.txt > tucrs_pm10kb.bed

bedtools slop -b 10000 -i TUCR_intergenic.sort.bed -g hg38_genomeFile.txt > intergenic_tucrs_pm10kb.bed

#bedtools slop -b 10000 -i CHESScoding.sort.bed -g hg38_genomeFile.txt > coding_pm10kb.bed

#bedtools slop -b 10000 -i CHESSlncRNA.sort.bed -g hg38_genomeFile.txt > lncRNAs_pm10kb.bed

#bedtools slop -b 10000 -i CHESSantisense.sort.bed -g hg38_genomeFile.txt > antisense_pm10kb.bed

#bedtools slop -b 10000 -i CHESSmisc.sort.bed -g hg38_genomeFile.txt > misc_pm10kb.bed

```

### Fisher

```{bash Section1_fisher, results="hide", eval = FALSE}

bedtools fisher -a tucrs_pm10kb.bed -b pol2shuff.sort.bed -g hg38_genomeFile.txt > pol2_random_output.txt

bedtools fisher -a tucrs_pm10kb.bed -b pol2.sort.bed -g hg38_genomeFile.txt > pol2_tucrs_output.txt

bedtools fisher -a intergenic_tucrs_pm10kb.bed -b pol2.bed -g hg38_genomeFile.txt > pol2_intergenic_tucrs_output.txt

bedtools fisher -a CHESScoding.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt > pol2_coding_output.txt

bedtools fisher -a CHESSlncRNA.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt > pol2_lncRNA_output.txt

bedtools fisher -a CHESSantisense.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt > pol2_antisense_output.txt

bedtools fisher -a CHESSmisc.sort.bed -b pol2.sort.bed -g hg38_genomeFile.txt > pol2_misc_output.txt

bedtools fisher -a tucrs_pm10kb.bed -b h3k4me3shuff.sort.bed -g hg38_genomeFile.txt > h3k4me3_random_output.txt

bedtools fisher -a tucrs_pm10kb.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_tucrs_output.txt

bedtools fisher -a intergenic_tucrs_pm10kb.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_intergenic_tucrs_output.txt

bedtools fisher -a CHESScoding.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_coding_output.txt

bedtools fisher -a CHESSlncRNA.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_lncRNA_output.txt

bedtools fisher -a CHESSantisense.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_antisense_output.txt

bedtools fisher -a CHESSmisc.sort.bed -b h3k4me3.sort.bed -g hg38_genomeFile.txt > h3k4me3_misc_output.txt

```

### Show that TUCRs are enriched for hallmarks of lncRNAs

```{r Section1_lncRNAs}
if(makeannotate == TRUE){
tucr_lncRNAs <- read.csv("tucr_lncRNAs.csv")

tucr_lncRNAs <- tucr_lncRNAs %>%
  mutate(row = fct_reorder(row,Order))
  
p <- ggplot(tucr_lncRNAs, aes(x=row,y=value,fill=as.factor(fill)))                + 
  geom_bar(
    stat="identity", 
    color = "black",width=0.7)                                                      + 
  scale_fill_manual(values = c("red3","green4","blue3","deeppink","yellow2","orange2")) +
  #geom_text(
  #  aes(label=round(value,2)), 
  #  vjust=1.6, 
  #  color="black", 
  #  size=rel(4))                                                      #+ 
  ggtitle(paste("TUCRs are enriched for \n RNA Pol.II and H3K4me3"))  + 
  xlab("Interval and Mark")                                           + 
  ylab("-log10 of p-value")                                           + 
  theme(
    plot.title = element_text(
      size=rel(1.5), 
      face="bold",hjust = 0.5),
    axis.title = element_text(
      size = rel(1.25), 
      face="bold"),
    axis.text.x = element_text(
      angle = -90, 
      size = 10),
    legend.title = element_blank(),
    legend.position = "none",
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    panel.background = element_blank(), 
    axis.line = element_line(
      colour = "black")) #+
    #facet_wrap(~wrap)

ggsave(
    file=paste(outputdir,"/",disease,"_tucr_lncRNAs.png",sep=""),
    plot = print(p),
    width = 5, 
    height = 5, 
    dpi = 300) 
}
```

# Section 2: TUCRs are deregulated in GBM and LGG tumors

## Results

TUCR expression has not been characterized in glioblastoma (GBM) or low-grade gliomas (LGG).  We performed the first comprehensive bioinformatic analysis of TUCR expression in these diseases by comparing GBM and LGG tumor samples from the Cancer Genome Atlas (TCGA) to their normal brain counterparts.  Of the 481 TUCRs, we identified 115 and 82 that were up- and downregulated in GBM, respectively. (Figure 3A) We also identified 58 and 91 TUCRs that were up- and downregulated in LGG. (Figure 3B) Of the 157 deregulated TUCRs in LGG, 109 were also deregulated in GBM, a 70% overlap. (Figure 3C) Intergenic TUCRs are of particular interest; they may represent markers for novel genes.  Amongst intergenic TUCRs, we identified 6 up- and 6- downregulated TUCR by a magnitude greater that 2-fold and with an FDR of 0.05 or less (Figure 3D).  We performed these same analyses in LGG and identified 3 up- and 5 downregulated TUCRs. (Figure 3E) For both disease types, uc.110 and uc.62 represented the most up- and downregulated TUCRs, respectively.

### Setup for RNA-Seq analyses

The next part of this analysis involves using bash and R scripts to identify TUCRs that are deregulated and/or correlated with survival in GBM and LGG. The GBM analyses were stored in a directory named tcga_analysis, while the LGG analyses were stored in the lgg_tcga_analysis.  The following script generates these two directories.

### Make Directories

```{bash Section2_mkdir, eval = FALSE}
## Create directory for all raw data from RNA-Seq analysis
mkdir RNASEQ-RAW

## Create directory for all processed data from RNA-Seq analysis
mkdir RNASEQ-PROCESSED

## Create directory for all TCGA analyses.
mkdir RNASEQ-PROCESSED/tcga_analysis/

## Create a subdirectory for each disease
mkdir RNASEQ-PROCESSED/tcga_analysis/GBM

mkdir RNASEQ-PROCESSED/tcga_analysis/LGG

## Create directory for all GTex analyses.
mkdir RNASEQ-PROCESSED/gtex_analysis/

## Create a subdirectory for cortex samples
mkdir RNASEQ-PROCESSED/gtex_analysis/cortex/reindex/

```

### GTEX Processing: Download RNA-Seq Data

Profile = mkgibertjr

Manifest = file-manifest-cortexonly.json

Download-Path = ./RNASEQ-PROCESSED/gtex_analysis/cortex/reindex/

```{r Section2_GTexManifest}

GTexManifest <- fromJSON("file-manifest.json")

NeedGTex <- read.table("GTex_Cortex.txt",header=TRUE)

GTexManifest <- GTexManifest %>%
  mutate(SAMPID = str_remove(file_name,".Aligned.sortedByCoord.out.patched.md.bam")) %>%
  left_join(NeedGTex, by="SAMPID")

GTexManifest <- GTexManifest[complete.cases(GTexManifest),]

GTexManifest <- GTexManifest %>%
  select(-SAMPID,-SMTSD)

write_json(GTexManifest,"file-manifest-cortexonly.json",pretty=TRUE)

```

```{bash Section2_GTexDownload, eval=false}

./gen3-client configure --profile=<mkgibertjr>
--cred=<credentials.json>
--apiendpoint=https://gen3.theanvil.io

yes | ./gen3-client download-multiple --profile=mkgibertjr --manifest=file-manifest-cortexonly.json --download-path=./gtex_analysis/ --protocol=s3

```

### GTEX Processing: Reindex GTex BAM files

```{bash Section2_gtexindex, eval = FALSE}

# Reindex the renamed files using samtools.
for bam in $(find mkdir RNASEQ-PROCESSED/gtex_analysis/cortex/reindex -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools index $bam
done

```

We will complete the counts after processing the TCGA data in a similar fashion.

### GTEX Processing: Acquiring total reads from RNA-Seq BAM files

```{bash Section2_gtexseqdepth, eval = FALSE}

mkdir RNASEQ-PROCESSED/gtex_analysis/cortex/readcounts/

for bam in $(find RNASEQ-PROCESSED/gtex_analysis/cortex/reindex/*.bam -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -c -F 260 $bam > $name.readcounts.txt
mv $name.readcounts.txt ./RNASEQ-PROCESSED/gtex_analysis/cortex/readcounts/
done

echo "id,counts" > RNASEQ-PROCESSED/gtex_analysis/cortex/readcounts/cortex_seqdepth_counts.csv 

for txt in $(find RNASEQ-PROCESSED/gtex_analysis/cortex/readcounts/* -name '*.txt')
do
name=$(echo $txt | awk -F ".readcounts.txt" '{print $1}')
echo $name
reads=$(head $txt)
echo "$name,$reads" >> RNASEQ-PROCESSED/gtex_analysis/cortex/readcounts/cortex_seqdepth_counts.csv 
done

```

### TCGA Processing: Extract headers from BAM files

The raw BAM files for GBM and LGG were stored in GBM-RNASEQ-RAW and LGG-RNASEQ-RAW, respectively.  Since these files are labeled with unintuitive and encrypted names, I will generate clones of each BAM file using the TCGA ID as the name instead.  This will make it easier to see which files are normal brain and which are tumors at a glance.  TCGA files are not named this way by default because there is patient information contained within the BAM files that can be identified using the TCGA ID.  Therefore, renaming the file in secure storage is preferrable.  The first step to doing this is extracting the TCGA ID from the header present in each BAM file. 

In the following series of scripts, a bash script was used to extract the header from each encrypted BAM file and generate a text file containing the full header. 

```{bash Section2_tcgaheader, eval = FALSE}
## Extract header information from GBM BAM files
# Create directory for extracted headerfiles
mkdir RNASEQ-PROCESSED/tcga_analysis/GBM/head/

# Use a for loop to cycle through BAM files and extract header before creating a 
#text file containing each BAM file's header.
for bam in $(find RNASEQ-RAW/GBM/* -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -H $bam > $name.headerids.txt
mv $name.headerids.txt ./RNASEQ-PROCESSED/tcga_analysis/GBM/head/
done

## Do the same thing for LGG
# Create directory for extracted headerfiles
mkdir RNASEQ-PROCESSED/tcga_analysis/LGG/head/

for bam in $(find RNASEQ-RAW/LGG/* -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -H $bam > $name.headerids.txt
mv $name.headerids.txt ./RNASEQ-PROCESSED/tcga_analysis/LGG/head/
done
```

### TCGA Processing: Extract TCGA patient barcodes from BAM headers

Once the headers have been extracted from each BAM file, the TCGA ID is then extracted from each header.  A master table is generated that contains the encrypted BAM file name and the new TCGA ID based named, which will be used to generate the renamed clone files in the next step.

```{bash Section2_tcgaids, eval = FALSE}
## Get new file names for BAM files using TCGA IDs from extracted header
mkdir RNASEQ-PROCESSED/tcga_analysis/GBM/ids/

mkdir RNASEQ-PROCESSED/tcga_analysis/LGG/ids/

# Initialize summary file with TCGA IDs
echo "RAWID,TCGAID" > RNASEQ-PROCESSED/tcga_analysis/GBM/ids/tcgaIDs.csv

# Extract IDs from header files
for header in $(find RNASEQ-PROCESSED/tcga_analysis/GBM/head/* -name '*headerids.txt')
do
name=$(echo $header | awk -F ".headerids.txt" '{print $1}')
name2=$(echo $name | cut -c20-)
ids1=$(awk '$1=="@RG"{print $3}' $header)
ids2=$(echo $ids1 | cut -c4-)
echo "$name2.bam,$ids2.bam"
echo "$name2.bam,$ids2.bam" > $name.tcgaid.csv
echo "$name2.bam,$ids2.bam" >> RNASEQ-PROCESSED/tcga_analysis/GBM/ids/tcgaIDs.csv
mv $name.tcgaid.csv ./RNASEQ-PROCESSED/tcga_analysis/GBM/ids/
done

## Do the same thing for LGG

# Initialize summary file with TCGA IDs
echo "RAWID,TCGAID" > RNASEQ-PROCESSED/tcga_analysis/LGG/ids/tcgaIDs.csv 

# Extract IDs from header files
for header in $(find RNASEQ-PROCESSED/tcga_analysis/LGG/head/* -name '*headerids.txt')
do
name=$(echo $header | awk -F ".headerids.txt" '{print $1}')
name2=$(echo $name | cut -c24-)
ids1=$(awk '$1=="@RG"{print $3}' $header)
ids2=$(echo $ids1 | cut -c4-)
echo "$name2.bam,$ids2.bam"
echo "$name2.bam,$ids2.bam" > $name.tcgaid.csv
echo "$name2.bam,$ids2.bam" >> RNASEQ-PROCESSED/tcga_analysis/LGG/ids/tcgaIDs.csv 
mv $name.tcgaid.csv ./RNASEQ-PROCESSED/tcga_analysis/LGG/ids/
done
```

### TCGA Processing: Reindex TCGA BAM files under new names

```{bash Section2_tcgaindex, eval = FALSE}

##Rename BAM files using TCGA ids

# Create folder for new files
mkdir RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/

# Copy BAM files into new directory with updated names
while IFS=, read orig target; do
orig2=$(find RNASEQ-RAW/GBM/* -name $orig)
echo $orig2
cp $orig2 $target
mv $target RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/
done < RNASEQ-PROCESSED/tcga_analysis/GBM/ids/tcgaIDs.csv

# Reindex the renamed files using samtools.
for bam in $(find RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/ -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools index $bam
done

## Do the same thing for LGG
# Create folder for new files
mkdir RNASEQ-PROCESSED/tcga_analysis/LGG/reindex

# Copy BAM files into new directory with updated names
while IFS=, read orig target; do
orig2=$(find RNASEQ-RAW/LGG/* -name $orig)
echo $orig2
cp $orig2 $target
mv $target RNASEQ-PROCESSED/tcga_analysis/LGG/reindex/
done < RNASEQ-PROCESSED/tcga_analysis/LGG/ids/tcgaIDs.csv

# Reindex the renamed files using samtools.
for bam in $(find RNASEQ-PROCESSED/tcga_analysis/LGG/reindex/ -name '*.bam')
do
samtools view -H TCGA-CS-4938-01B-11R-1896-07.bam > header
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools reheader header $bam > $name.rehead.bam
samtools index $name.rehead.bam
done

```

### TCGA Processing: Acquiring total reads from RNA-Seq BAM files

```{bash Section2_tcgaseqdepth, eval = FALSE}

mkdir RNASEQ-PROCESSED/tcga_analysis/GBM/readcounts/

for bam in $(find RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/*.bam -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -c -F 260 $bam > $name.readcounts.txt
mv $name.readcounts.txt ./RNASEQ-PROCESSED/tcga_analysis/GBM/readcounts/
done

echo "id,counts" > RNASEQ-PROCESSED/tcga_analysis/GBM/readcounts/GBM_seqdepth_counts.csv 

for txt in $(find RNASEQ-PROCESSED/tcga_analysis/GBM/readcounts/* -name '*.txt')
do
name=$(echo $txt | awk -F ".readcounts.txt" '{print $1}')
echo $name
reads=$(head $txt)
echo "$name,$reads" >> RNASEQ-PROCESSED/tcga_analysis/GBM/readcounts/GBM_seqdepth_counts.csv 
done

## Do the same for LGG

mkdir RNASEQ-PROCESSED/tcga_analysis/LGG/readcounts/

for bam in $(find RNASEQ-PROCESSED/tcga_analysis/LGG/reindex/*.bam -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -c -F 260 $bam > $name.readcounts.txt
mv $name.readcounts.txt ./RNASEQ-PROCESSED/tcga_analysis/LGG/readcounts/
done

echo "id,counts" > RNASEQ-PROCESSED/tcga_analysis/LGG/readcounts/LGG_seqdepth_counts.csv 

for txt in $(find RNASEQ-PROCESSED/tcga_analysis/LGG/readcounts/* -name '*.txt')
do
name=$(echo $txt | awk -F ".readcounts.txt" '{print $1}')
echo $name
reads=$(head $txt)
echo "$name,$reads" >> RNASEQ-PROCESSED/tcga_analysis/LGG/readcounts/LGG_seqdepth_counts.csv 
done

```

### Generate BED files to get counts

```{r Section2_bedbreaker}

if(!dir.exists("BEDFiles")){dir.create("BEDFiles")}

if(makeBEDs == TRUE){
bedbreaker <- function(file){  

bed <- read.table(file)
chrom <- unique(as.vector(bed$V1))
i = 1

for(i in 1:length(chrom)){
  x <- bed %>%
    filter(V1 == chrom[i]) %>%
    write.table(paste("BEDFiles/",chrom[i],"_genes.bed",sep=""),quote = F,col.names = F,row.names = F,sep = '\t')
}}

bedbreaker("BEDFiles/allgenes.bed")
}

## MOVE these files to the RNASEQ-PROCESSED directory in the next step

```

### Move BED Files to RNASEQ-PROCESSED Directory

```{bash Section2_mkdir_BEDFiles}

mkdir RNASEQ-PROCESSED/BEDFiles

```


### GTEX Processing: Generating count tables for survival and differential expression.

```{bash Section2_gtexcounts, eval = FALSE}
# Making directory
mkdir RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange

for bed in $(find RNASEQ-PROCESSED/BEDFiles/ -name '*.bed')
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
name2=$(basename -- $name)
echo $name2

if test -f $name2.counts.txt; then

echo "$name2.counts.txt exists."

else

echo -e chrom"\t"start"\t"end"\t"strand"\t"id"\t"tag"\t"annot RNASEQ-PROCESSED/gtex_analysis/cortex/reindex/*bam | sed -e "s/ /\t/g" > RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/$name2.counts.txt

multiBamCov -bams RNASEQ-PROCESSED/gtex_analysis/cortex/reindex/*bam -bed $bed -q 10 >> RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/$name2.counts.txt

fi
done

head -1 RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/chr10_genes.counts.txt > RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/cortex_mergedcounts.txt; tail -n +2 -q RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/*.counts.txt >> RNASEQ-PROCESSED/gtex_analysis/cortex/foldchange/cortex_mergedcounts.txt

```

### TCGA Processing: Generating count tables for survival and differential expression.

```{bash Section2_gtexcounts, eval = FALSE}
# Making directory
mkdir RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange

for bed in $(find RNASEQ-PROCESSED/BEDFiles/ -name '*.bed')
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
name2=$(basename -- $name)
echo $name2

if test -f $name2.counts.txt; then

echo "$name2.counts.txt exists."

else

echo -e chrom"\t"start"\t"end"\t"strand"\t"id"\t"tag"\t"annot RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/*bam | sed -e "s/ /\t/g" > RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/GBM_mergedcounts.txt$name2.counts.txt

multiBamCov -bams RNASEQ-PROCESSED/tcga_analysis/GBM/reindex/*bam -bed $bed -q 10 >> RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/$name2.counts.txt

fi
done

head -1 RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/chr10_genes.counts.txt > RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/GBM_mergedcounts.txt; tail -n +2 -q RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/*.counts.txt >> RNASEQ-PROCESSED/tcga_analysis/GBM/foldchange/GBM_mergedcounts.txt

# Making directory
mkdir RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange

for bed in $(find RNASEQ-PROCESSED/BEDFiles/ -name '*.bed')
do

name=$(echo $bed | awk -F ".bed" '{print $1}')
name2=$(basename -- $name)
echo $name2

if test -f $name2.counts.txt; then

echo "$name2.counts.txt exists."

else

echo -e chrom"\t"start"\t"end"\t"strand"\t"id"\t"tag"\t"annot RNASEQ-PROCESSED/tcga_analysis/LGG/reindex/*bam | sed -e "s/ /\t/g" > RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/$name2.counts.txt

multiBamCov -bams RNASEQ-PROCESSED/tcga_analysis/LGG/reindex/*bam -bed $bed -q 10 >> RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/$name2.counts.txt

fi
done

head -1 RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/chr10_genes.counts.txt > RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/LGG_mergedcounts.txt; tail -n +2 -q RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/*.counts.txt >> RNASEQ-PROCESSED/tcga_analysis/LGG/foldchange/LGG_mergedcounts.txt

```

### Identifying differentially expressed TUCRs with DESeq2

```{r Section2_DESeq2_TUCRs}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis",sep=""))
}

if(!is.na(n_countfile)){
  mergedcounts <- read.table(t_countfile,header = TRUE)
  
  normalcounts <- read.table(n_countfile,header = TRUE) 
  
  mergedcounts <- mergedcounts %>% left_join(normalcounts,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y) %>%
    distinct()
  
  metadata <- 
  read_csv(file = t_metadatafile)
  
  n_metadata <- 
  read_csv(file = n_metadatafile)
  
  metadata <- rbind(metadata,n_metadata)
  
}else{
    mergedcounts <- read.table(t_countfile,header = TRUE)

    metadata <- read_csv(file = t_metadatafile)
}

if(!is.na(filterannot)){
  mergedcounts <- mergedcounts %>%
    filter(tag.x == filterannot)
}



mergedcounts2 <- 
  mergedcounts[,8:ncol(mergedcounts)]

rownames(mergedcounts2) <- 
  mergedcounts[,4]

mergedcounts.info <- 
  mergedcounts[,1:6]

mergedcounts.info$length <- 
  (mergedcounts$end.x - mergedcounts$start.x)/1000

mergedcounts <- 
  cbind(mergedcounts.info,mergedcounts2)

#write.csv(mergedcounts2,"mergedcounts2.csv")

dds <- 
  DESeqDataSetFromMatrix(countData = mergedcounts2,
                              colData = metadata,
                              design = ~dex)

```

## QC for normal samples

I am using Stephen Turner's PCA function and plots for this analysis.

```{r Section2_PCA}

if(!dir.exists(paste(outputdir,"/QualityControl/",sep=""))){
  dir.create(paste(outputdir,"/QualityControl/",sep=""))
}

#Stephen's PCA Function
ggpca <- function (x, intgroup = "condition", ntop = 500, returnData = FALSE, labelpoints=FALSE)
{
  rv <- matrixStats::rowVars(assay(x))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca <- prcomp(t(assay(x)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(x)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(x)[, intgroup, drop = FALSE])
  group <- factor(apply(intgroup.df, 1, paste, collapse = " : "))
  d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], group = group,
                  intgroup.df, names = colnames(x))
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:2]
    return(d)
  }
  p <- ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "group", label="names")) +
    geom_point(size = 3) +
    xlab(paste0("PC1: ", round(percentVar[1] * 100, digits=2), "% variance")) +
    ylab(paste0("PC2: ", round(percentVar[2] * 100, digits=2), "% variance"))
  if (labelpoints) {
    p <- p+geom_text(hjust=0, vjust=0)
  }
  p
}

## PCA
rld <- varianceStabilizingTransformation(dds)

ggpca(rld, intgroup = c("dex"), labelpoints=FALSE) + xlim(-20, 25) + ylim(-15,15)
ggsave(paste(outputdir,"/QualityControl/aboundaer-tucr-qc-pca.png",sep=""), w=10, h=10, scale=.9)

```

### Identifying differentially expressed TUCRs with DESeq2 (Continued)

```{r Section2_DESeq2_TUCRs_continued}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",sep=""))
}

dds <- 
  DESeq(dds)

res <- 
  results(dds, tidy=TRUE)

res <- 
  as_tibble(res)

if(!is.na(filterannot) & filterannot != ""){
write.csv(res, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_",filterannot,".csv",sep=""))}else{
write.csv(res, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_allgenes.csv",sep=""))
}

res_summary <- 
  res %>%
  mutate(dereg = 
           ifelse(res$log2FoldChange >=1, "upregulated",
                    ifelse(res$log2FoldChange <=-1,"downregulated","unchanged"))) %>%
  filter(dereg == "upregulated" | dereg == "downregulated") %>%
  group_by(dereg) %>%
  summarise(n = n()) %>%
  mutate(count = ifelse(dereg=="downregulated",-n,n))

p <- ggplot(res_summary, aes(x=dereg,y=n,fill=dereg)) + 
  geom_bar(stat="identity", width = 0.7, 
    color = "black") + 
  geom_text(aes(label=n), vjust=1.6, color="black", size=7) + 
  scale_fill_manual(values=c("green", "red")) + 
  ggtitle(paste(filterannot," Deregulation in ",disease)) + 
  xlab("Direction of Deregulation") + 
  ylab("Number of Deregulated Genes") + 
  theme(
    plot.title = element_text(size=rel(1.5), face="bold",hjust = 0.5),
    axis.title = element_text(size = rel(1.25), face="bold"),
    legend.title = element_blank(),
    legend.position = "none",
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    panel.background = element_blank(), 
    axis.line = element_line(colour = "black"))

ggsave(file=paste(outputdir,"/ExpressionAnalysis/",disease,"_deregGraph_",filterannot,".png",sep=""),
       plot = print(p),
       width = 5, 
       height = 5, 
       dpi = 300)

```

### Writing a script to generate a volcano plot

```{r Section2_volcanoplot}

### Volcano plot

volcanoplot <- function (res,
                         genes = "all",
                         title = paste("Deregulated Genes in ",disease,sep=""), 
                         output = paste("/ExpressionAnalysis",disease,"_results_volcanoplot.png",sep=""),
                         height = 7, 
                         width = 7, 
                         dpi = 300){
  #res <- res_TUCR
  #genes = c("uc.110","uc.62")
  #title = "Deregulated Genes"
  vres <- res
  vres <- vres %>% 
    mutate(filter1 = abs(log2FoldChange)>=1,filter2 = padj <=0.05,Legend="",gene="")
  
  for (i in 1:length(vres$row)){
    if(is.na(vres$padj[i])){vres$Legend[i] <- "Not deregulated"}else{
    if(vres$filter1[i] == TRUE && vres$filter2[i] == TRUE){
    vres$Legend[i] <- ">2-Fold & <0.05 FDR"
  }else{
      if(vres$filter1[i] == TRUE){
    vres$Legend[i] <- ">2-Fold"
      }else{vres$Legend[i] <- "Not deregulated"}
  }}
    ifelse(genes!="all",
           ifelse(!is.na(match(vres$row[i],genes)),vres$gene[i] <- vres$row[i], ""),vres$gene[i] <- vres$row[i])
  }
  
  vres <- vres %>%
    mutate(color = ifelse(Legend==">2-Fold & <0.05 FDR","red",
                   ifelse(Legend==">2-Fold","blue",
                   ifelse(Legend=="Not deregulated","black","gray"
                          ))),
           order = ifelse(Legend==">2-Fold & <0.05 FDR",1,
                   ifelse(Legend==">2-Fold",2,
                   ifelse(Legend=="Not deregulated","black",3
                          )))) %>%
    arrange(order)
  
  ## plot
if(repel==TRUE){p <- ggplot(vres) + 
  geom_point(aes(x=log2FoldChange, y=-log10(padj),col=color)) + 
  scale_color_identity(guide = "legend", labels = vres$Legend, breaks = vres$color) + 
  ggtitle(title) + 
  labs(x = "log2 fold change",
        ylab = "-log10 adjusted p-value",
        color = "Legend") + 
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
              axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) + 
  geom_text_repel(aes(x=log2FoldChange, y=-log10(padj),label = gene),force=25,hjust=1,vjust=1) +
  coord_cartesian(clip = "off")}
else{p <- ggplot(vres) +
        geom_point(aes(x=log2FoldChange, y=-log10(padj),col=color)) +
        scale_color_identity(guide = "legend", labels = vres$Legend, breaks = vres$color) +
        ggtitle(title) +
        labs(x = "log2 fold change",
        ylab = "-log10 adjusted p-value",
        color = "Legend") +
        theme(plot.title = element_text(size = rel(1.5), hjust = 0.5, face="bold",margin=margin(0,0,0,0)),
              axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  coord_cartesian(clip = "off")}
ggsave(output, width = width, height = height, dpi = dpi)
}

```

### Generating volcano plot to visualize DE genes

```{r Section2_DESeq2plots_TUCRs}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",sep=""))
}

volcanoplot(res,genes=c("uc.110","uc.210","uc.427","uc.62"),
            title = paste("Deregulated Genes in ",disease,sep=""), 
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_myron_tucr_results_volcanoplot.png",sep=""))

repel_hold = repel

repel = FALSE

volcanoplot(res,
            title = paste("Deregulated Genes in ",disease,sep=""), 
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_tucr_results_volcanoplot.png",sep=""))

repel = repel_hold

```

### Volcano plot for intergenic TUCRs only

```{r Section2_DESeq2plots_annotatedTUCRs}

tucr_annot <- read.table("BEDFiles/hg38.ultraconserved.bed") %>%
  dplyr::select("row" = V4, "annot" = V7)

res_intergenic <- inner_join(res,tucr_annot,by = "row") %>%
  filter(annot == "intergenic")

write.csv(res_intergenic, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_intergenicOnly.csv",sep=""))

volcanoplot(res_intergenic,genes=c("uc.62","uc.110"), 
            title = paste("Intergenic TUCR deregulation in ",disease,sep=""),
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_intergenic_tucr_results_volcanoplot.png",sep=""))

res_exonic <- inner_join(res,tucr_annot,by = "row") %>%
  filter(annot == "exonic")

write.csv(res_exonic, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_exonicOnly.csv",sep=""))

volcanoplot(res_exonic,genes=c("uc.90","uc.213"), 
            title = paste("exonic TUCR deregulation in ",disease,sep=""),
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_exonic_tucr_results_volcanoplot.png",sep=""))

res_intronic <- inner_join(res,tucr_annot,by = "row") %>%
  filter(annot == "intronic")

write.csv(res_intronic, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_intronicOnly.csv",sep=""))

volcanoplot(res_intronic,genes=c("uc.430","uc.35"), 
            title = paste("intronic TUCR deregulation in ",disease,sep=""),
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_intronic_tucr_results_volcanoplot.png",sep=""))

res_exonic_intronic <- inner_join(res,tucr_annot,by = "row") %>%
  filter(annot == "exonic_intronic")

write.csv(res_exonic_intronic, file = paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_exonic_intronicOnly.csv",sep=""))

volcanoplot(res_exonic_intronic,genes=c("uc.282","uc.341"), 
            title = paste("exonic/intronic TUCR deregulation in ",disease,sep=""),
            output = paste(outputdir,"/ExpressionAnalysis/VolcanoPlots/",disease,"_exonic_intronic_tucr_results_volcanoplot.png",sep=""))

```

### Determining sequencing depth for TCGA files

```{bash Section3_seqdepth, eval = FALSE}
mkdir tcga_analysis/readcounts/

for bam in $(find tcga_analysis/reindex/*.bam -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -c -F 260 $bam > $name.readcounts.txt
mv $name.readcounts.txt ./tcga_analysis/readcounts/
done

##Do the same for lgg

mkdir lgg_tcga_analysis/readcounts/

for bam in $(find lgg_tcga_analysis/reindex/*.bam -name '*.bam')
do
name=$(echo $bam | awk -F ".bam" '{print $1}')
echo $name
samtools view -c -F 260 $bam > $name.readcounts.txt
mv $name.readcounts.txt ./lgg_tcga_analysis/readcounts/
done


```

### Identifying and comparing TUCR absolute expression in GBM and LGG

```{r Section2_RPKM_TUCRs}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/RPKM_allresults/",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/RPKM_allresults/",sep=""))
}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/RPKM_medianonly/",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/RPKM_medianonly/",sep=""))
}


if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/RPKM_heatmaps/",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/RPKM_heatmaps/",sep=""))
}

if(!is.na(n_countfile)){
  mergedcounts <- read.table(t_countfile,header = TRUE)
  
  normalcounts <- read.table(n_countfile,header = TRUE) 
  
  mergedcounts <- mergedcounts %>% left_join(normalcounts,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y) %>%
    distinct()
  
  metadata <- 
  read_csv(file = t_metadatafile)
  
  n_metadata <- 
  read_csv(file = n_metadatafile)
  
  metadata <- rbind(metadata,n_metadata)
  
  seqdepth <- read.csv(file = t_seqdepthfile)
  
  n_seqdepth <- read.csv(file = n_seqdepthfile)
  
  seqdepth <- rbind(seqdepth,n_seqdepth)
  
}else{
    mergedcounts <- read.table(t_countfile,header = TRUE) %>%
    distinct()

    metadata <- read_csv(file = t_metadatafile)
    
    seqdepth <- read.csv(file = t_seqdepthfile)
}

if(!is.na(filterannot)){
  rpkmcounts <- mergedcounts %>%
  filter(tag.x == filterannot) %>%
  mutate(length = end.x - start.x)
}else{
rpkmcounts <- mergedcounts %>%
  mutate(length = end.x - start.x)}

rpkmcounts.info <- rpkmcounts %>%
  dplyr::select(chrom.x,start.x,end.x,length,id,strand.x,tag.x,annot.x)

rpkmcounts <- rpkmcounts %>%
  dplyr::select(-chrom.x,-start.x,-end.x,-id,-strand.x,-tag.x,-annot.x)
  
rownames(rpkmcounts) <- as.character(rpkmcounts.info$id)

genelength <- rpkmcounts.info$length/1000

seqdepth2 <- as.vector(seqdepth$counts)/1000000

rpkm <- function(counts,len,dep){
  x <- counts/len
  return(t(t(x)/(dep)))
}

tpm <- function(counts,len){
  x <- counts/len
  x_sum <- sum(x)/1000000
  return(t(t(x)/(x_sum)))
}

if(RPKmethod == "tpm" | RPKmethod == "TPM"){
rpkm.df <- tpm(rpkmcounts,genelength)  
}else{
rpkm.df <- rpkm(rpkmcounts,genelength,seqdepth2)  
}

rpkm.df2 <- cbind(rpkmcounts.info,rpkm.df)

rpkm.median <- as.data.frame(rpkm.df)
rpkm.median <- rpkm.median %>% 
  dplyr::summarize(median_RPKM = rowMedians(rpkm.df)) %>%
  dplyr::mutate(countif = ifelse(median_RPKM >=1,1,0),proportion = sum(countif,na.rm = TRUE)/n())
rpkm.median <- cbind(rpkmcounts.info,rpkm.median)
rpkm.median <- rpkm.median %>% dplyr::select(id,median_RPKM,countif,proportion)

proportion.df <- round(as.numeric(rpkm.median$proportion[1]),3)*100

write.csv(rpkm.df2,paste(outputdir,"/ExpressionAnalysis/RPKM_allresults/",disease,"_rpkm_allTUCRs.csv",sep=""))

write.csv(rpkm.median,paste(outputdir,"/ExpressionAnalysis/RPKM_medianonly/",disease,"_medianrpkm_allTUCRs.csv",sep=""))

heatmap.df <- rpkm.df
geneids <- rpkm.df2 %>%
  dplyr::select(id)
means <- apply(heatmap.df,1,mean)

heatmap.df2 <- as.data.frame(apply(heatmap.df,1:2,function(x) {ifelse(x>=10,10,x)}))
heatmap.df2 <- cbind(geneids,means,heatmap.df2)

heatmap.df2 <- heatmap.df2 %>% 
  gather(key = "Sample", value = "RPKM",-id,-means)

p <- ggplot(data = heatmap.df2,mapping = aes(x = Sample,y = reorder(id,means), fill = RPKM)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("blue", "white", "red"), values = c(0,0.1,1)) + ggtitle(paste("All TUCRs (",proportion.df,"%)",sep="")) + xlab(paste("Samples (n = ",ncol(heatmap.df),")",sep="")) + ylab(paste("genes (n = ",nrow(heatmap.df),")",sep="")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggsave(p,file=paste(outputdir,"/ExpressionAnalysis/RPKM_heatmaps/",disease,"_allTUCRs_heatmap.png",sep=""), width = 2.5, height = 7, dpi = 300)

  rpkm.TUCRs2 <- rpkm.df2
  write.csv(rpkm.TUCRs2,paste(outputdir,"/ExpressionAnalysis/",disease,"_rpkm_TUCRs2.csv",sep=""))



i <- 1

for(i in 1:length(unique(mergedcounts$annot))){
  
annot_unique <- as.character(unique(mergedcounts$annot))

annotation <- as.character(annot_unique[i])

print(i)
print(annotation)
    
rpkmcounts <- mergedcounts %>%
  filter(annot.x == annotation) %>%
  mutate(length = end.x - start.x)

#rpkmcounts <- rpkmcounts[481,]

rpkmcounts.info <- rpkmcounts %>%
  dplyr::select(chrom.x,start.x,end.x,length,id,strand.x,tag.x,annot.x)

rpkmcounts <- rpkmcounts %>%
  dplyr::select(-chrom.x,-start.x,-end.x,-id,-strand.x,-tag.x,-annot.x)
  
#sum(is.na(mergedcounts$annot))
  
rownames(rpkmcounts) <- as.character(rpkmcounts.info$id)

genelength <- rpkmcounts.info$length/1000

seqdepth2 <- as.vector(seqdepth$counts)/1000000

rpkm <- function(counts,len,dep){
  x <- rpkmcounts/genelength
  x2 <- t(t(x)/(seqdepth2))
  x <- counts/len
  return(t(t(x)/(dep)))
}

rpkm.df <- rpkm(rpkmcounts,genelength,seqdepth2)  

rpkm.df2 <- cbind(rpkmcounts.info,rpkm.df)

rpkm.median <- as.data.frame(rpkm.df)
rpkm.median <- rpkm.median %>% 
  dplyr::summarize(median_RPKM = rowMedians(rpkm.df)) %>%
  dplyr::mutate(countif = ifelse(median_RPKM >=1,1,0),proportion = sum(countif,na.rm = TRUE)/n())
rpkm.median <- cbind(rpkmcounts.info,rpkm.median)
rpkm.median <- rpkm.median %>% dplyr::select(id,median_RPKM,countif,proportion)

proportion.df <- round(as.numeric(rpkm.median$proportion[i]),3)*100

write.csv(rpkm.df2,paste(outputdir,"/ExpressionAnalysis/RPKM_allresults/",disease,"_rpkm_",annotation,".csv",sep=""))

write.csv(rpkm.median,paste(outputdir,"/ExpressionAnalysis/RPKM_medianonly/",disease,"_medianrpkm_",annotation,".csv",sep=""))

heatmap.df <- rpkm.df
geneids <- rpkm.df2 %>%
  dplyr::select(id)
means <- apply(heatmap.df,1,mean)

heatmap.df2 <- as.data.frame(apply(heatmap.df,1:2,function(x) {ifelse(x>=10,10,x)}))
heatmap.df2 <- cbind(geneids,means,heatmap.df2)

heatmap.df2 <- heatmap.df2 %>% 
  gather(key = "Sample", value = "RPKM",-id,-means)

p <- ggplot(data = heatmap.df2,mapping = aes(x = Sample,y = reorder(id,means), fill = RPKM)) +
  geom_tile() +
  scale_fill_gradientn(colours = c("blue", "white", "red"), values = c(0,0.1,1)) + ggtitle(paste(annotation," (",proportion.df,"%)",sep="")) + xlab(paste("Samples (n = ",ncol(heatmap.df),")",sep="")) + ylab(paste("genes (n = ",nrow(heatmap.df),")",sep="")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggsave(p,file=paste(outputdir,"/ExpressionAnalysis/RPKM_heatmaps/",disease,"_",annotation,"_heatmap.png",sep=""), width = 2.5, height = 7, dpi = 300)

}

```

### Generate RPKM Box Plots for each TUCR

```{r Section2_boxplot_TUCRs}
if(makeRPKboxplots == TRUE){
  
if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/RPKboxplots",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/RPKboxplots",sep=""))
}
  
if(!is.na(n_countfile)){
  
  metadata <- 
  read_csv(file = t_metadatafile)
  
  n_metadata <- 
  read_csv(file = n_metadatafile)
  
  metadata <- rbind(metadata,n_metadata)
  
  
}else{
  
    metadata <- read_csv(file = t_metadatafile)
    
}
  
rpkm.TUCRs2 <- read.csv(paste(outputdir,"/ExpressionAnalysis/",disease,"_rpkm_TUCRs2.csv",sep=""),header=TRUE) %>%
  dplyr::select(-X)
rpkm.dotplot <- rpkm.TUCRs2[,9:ncol(rpkm.TUCRs2)]
TUCRids <- as.character(rpkm.TUCRs2$id)
annot <- as.character(rpkm.TUCRs2$tag.x)
length <- as.character(rpkm.TUCRs2$length)
rpkm.dotplot <- cbind(TUCRids,annot,length,rpkm.dotplot)
rpkm.dotplot <- rpkm.dotplot %>% 
  gather(key = "Sample", value = "RPKM",-TUCRids,-annot,-length) %>%
  mutate(Key = gsub("[.]","-",Sample)) %>%
    mutate(string = ifelse(str_detect(Key,"TCGA"),
                           sub(".*TCGA", "", Key),
                           sub(".*GTEX", "", Key)),
           barcode = ifelse(str_detect(Key,"TCGA"),
                            tolower(paste("TCGA",substr(string, 1, 8),sep="")),
                            tolower(paste("GTEX",substr(string, 1, 20),sep="")))) %>%
  left_join(metadata,by="barcode")

rpkm.dotplot <- rpkm.dotplot[complete.cases(rpkm.dotplot),]



rpkm.dotplot.nmeans <- rpkm.dotplot %>%
  filter(dex == "normal") %>%
  group_by(TUCRids) %>%
  mutate(median = median(RPKM,na.rm=TRUE)) %>%
  dplyr::select(TUCRids,median) %>%
  distinct()

i = 1
for(i in 1:length(TUCRids)){
#TUCR <- "uc.110"
TUCR <- TUCRids[i]
print(i)
print(TUCR)
rpkm.dotplot2 <- rpkm.dotplot %>%
  dplyr::filter(TUCRids == TUCR)

p<- ggplot(rpkm.dotplot2, aes(x=dex, y=RPKM)) +
  geom_boxplot(outlier.color="white") +
  #geom_violin(trim = FALSE)+
  #geom_point(pch=21, size=1.5) +
  geom_jitter(binaxis='y', stackdir='center', stackratio=0.90, dotsize=0.30,fill="gray") +
  ggtitle(paste(RPKmethod," expression of ",TUCR)) +
  theme(plot.title = element_text(hjust = 0.5),
  panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  labs(y=paste(ifelse((RPKmethod=="tpm"|RPKmethod=="TPM"),
                      "Transcripts per kilobase million (TPM)",
                      "Reads per kilobase million (RPKM)")),
       x = "Sample") +
  stat_summary(fun.y=mean, geom="point", shape=20, size=10, color="red", fill="red")
  

ggsave(p,file=paste(outputdir,"/ExpressionAnalysis/RPKboxplots/",disease,"_",TUCR,"_rpkm_boxplot.png",sep = ""))

}


}
```

## Generate FC Plots for each TUCR

```{r Section2_FC Plots}

if(!dir.exists(paste(outputdir,"/ExpressionAnalysis/FCplots",sep=""))){
  dir.create(paste(outputdir,"/ExpressionAnalysis/FCplots",sep=""))
}

if(!is.na(n_countfile)){
  mergedcounts <- read.table(t_countfile,header = TRUE)
  
  normalcounts <- read.table(n_countfile,header = TRUE) 
  
  mergedcounts <- mergedcounts %>% left_join(normalcounts,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y) %>%
    distinct()
  
  metadata <- 
  read_csv(file = t_metadatafile)
  
  n_metadata <- 
  read_csv(file = n_metadatafile)
  
  metadata <- rbind(metadata,n_metadata)
  
  seqdepth <- read.csv(file = t_seqdepthfile)
  
  n_seqdepth <- read.csv(file = n_seqdepthfile)
  
  seqdepth <- rbind(seqdepth,n_seqdepth)
  
}else{
    mergedcounts <- read.table(t_countfile,header = TRUE) %>%
    distinct()

    metadata <- read_csv(file = t_metadatafile)
    
    seqdepth <- read.csv(file = t_seqdepthfile)
}

if(!is.na(filterannot)){
  mergedcounts <- mergedcounts %>%
  filter(tag.x == filterannot)
}

is.sequential <- function(x){
  all(abs(diff(x)) == 1)
} 

posdata <- mergedcounts[,1:7]

mergedcounts <- mergedcounts[,8:length(colnames(mergedcounts))]

match_colnames <- match(as.character(colnames(mergedcounts)),as.character(metadata$survid))



mergedcounts <- as.matrix(mergedcounts)

n_index <- which(as.character(metadata$dex) %in% "normal")
t_index <- which(as.character(metadata$dex) %in% "tumor")

vm <- function(x){
  cond <- factor(ifelse(seq(1,dim(x)[2],1) %in% t_index, 1,  0))
  d <- model.matrix(~1+cond)
  x <- t(apply(x,1,as.numeric))
  ex <- voom(x,d,plot=F)
  return(ex$E)
}

count_vm <- vm(mergedcounts)

if(is.sequential(match_colnames)){
  print("metadata rows match countfile columns")
  colnames(count_vm) <- metadata$id
}else{
  "metadata rows do not match countfile columns"
}



scal <- function(x,y){
  median_n <- rowMedians(y)  # mean of normal
  sd_n <- apply(y,1,sd)  # SD of normal
  # z score as (value - mean normal)/SD normal
  res <- matrix(nrow=nrow(x), ncol=ncol(x))
  colnames(res) <- colnames(x)
  rownames(res) <- rownames(x)
  for(i in 1:dim(x)[1]){
    for(j in 1:dim(x)[2]){
      res[i,j] <- (x[i,j]-median_n[i])/sd_n[i]
    }
  }
  return(res)
}

z_rna <- scal(count_vm,count_vm[,n_index])

rownames(z_rna) <- posdata[,4]

fc_counts <- cbind(posdata,z_rna) %>%
  dplyr::select(-chrom.x,-start.x,-end.x,-strand.x,)

fc.dotplot <- fc_counts %>% 
  gather(key = "Sample", value = "ZScore",-id,-tag.x,-annot.x) %>%
  mutate(Key = gsub("[.]","-",Sample)) %>%
    mutate(string = ifelse(str_detect(Key,"TCGA"),
                           sub(".*TCGA", "", Key),
                           sub(".*GTEX", "", Key)),
           barcode = ifelse(str_detect(Key,"TCGA"),
                            tolower(paste("TCGA",substr(string, 1, 8),sep="")),
                            tolower(paste("GTEX",substr(string, 1, 20),sep="")))) %>%
  left_join(metadata,by="barcode")


res_TUCR <- read_csv(paste(outputdir,"/ExpressionAnalysis/DESeq2Results/",disease,"_results_",filterannot,".csv",sep="")) %>%
  dplyr::select("id.x"=row,log2FoldChange)

fc.dotplot <- fc.dotplot %>%
  left_join(res_TUCR,by="id.x") %>%
  mutate(DESeq2 = ifelse(dex=="normal",0,log2FoldChange)) %>%
  mutate(fill = ifelse(DESeq2 >= 1,"red",
                ifelse(DESeq2 <= -1,"green","lightgray"))) %>%
  dplyr::select(-Sample,-Key,-id.y,-string,-log2FoldChange) %>%
  filter(!is.na(dex))

i <- 1

for(i in 1:length(unique(fc.dotplot$id.x))){
  
filterdotplot <- as.character(unique(fc.dotplot$id.x[i]))

print(i)
print(filterdotplot)
  
fc.dotplot2 <- fc.dotplot %>%
  filter(id.x == filterdotplot)

foldchange.DESeq2 <- fc.dotplot2 %>%
  filter(dex == "tumor") %>%
  dplyr::select(DESeq2)

foldchange.DESeq2 <- round(foldchange.DESeq2[1,1],2)

fc.dotplot3 <- fc.dotplot2 %>%
  dplyr::select(dex,DESeq2,fill) %>%
  distinct()

p2 <- ggplot(data = fc.dotplot3,aes(x=dex, y=DESeq2,fill=fill)) +
  geom_bar(colour="black",stat="identity") +
  scale_fill_identity() +
  #scale_color_manual(values = c("black"="black","red"="red","green"="green")) +
  geom_jitter(data = fc.dotplot2, aes(x=dex, y=ZScore),binaxis='y', stackdir='center', stackratio=0.90, dotsize=0.30,fill="gray") +
  ggtitle(paste("Deregulation of ",filterdotplot," in ",disease," (",foldchange.DESeq2,"-log2fold)",sep="")) +
  theme(plot.title = element_text(hjust = 0.5),
  panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  labs(y="log2FoldChange", x = "Tissue Type")

ggsave(p2,file=paste(outputdir,"/ExpressionAnalysis/FCplots/",disease,"_",filterdotplot,"_FC_plot.png",sep = ""))

if(filterdotplot == "uc.110"){
write.csv(fc.dotplot2,file=paste(outputdir,"/ExpressionAnalysis/FCplots/",disease,"_",filterdotplot,"_zscoretable.csv",sep = ""))}

}



```

# Section 3: TUCR expression correlates with survival in LGG and GBM

## Results

Gene deregulation can sometimes result in a disparity in clinical outcomes.  We sought to identify whether deregulation of any of the 481 TUCRs correlate with patient outcomes in LGG and GBM.  For this exercise, we obtained LGG and GBM patient survival data from TCGA.  We then matched these patient outcomes to the patient RNA-Seq samples that were included in our differential expression analysis.  For each TUCR, we produced a Kaplan-Meier plot tracking differences in survival for high expressing and low expressing groups.  The high expression group represents the top quartile (25%) of expression values across the RNA-Seq samples; the low expression group represents the bottom quartile (25%) of expression values.  

Of the 310 TUCRs that were expressed in GBM TCGA RNA-Seq data, only 36 were correlated with survival in manner that was statistically significant (p-value < 0.05).  Of these 36 TUCRs, 9 had a statistically significant Cox proportional hazard that was associated with a good prognosis, while 7 had one that was associated with a poor prognosis.  The remaining 20 displayed a statistically significant difference in survival in our Kaplan-Meier analysis.  (Figure 3A)

We were initially surprised by the relatively (11.6%) small fraction of TUCRs that correlate with survival in GBM.  However, glioblastoma has a median survival of 15 months, which does not leave much room for dramatic differences in patient outcomes.  We also studied survival differences across LGG patients, as they have a much longer median survival (X months).  Because of this, we hypothesized that more TUCRs would correlate with survival in LGG.  Indeed, of the 293 TUCRs that were expressed in LGG TCGA RNA-Seq data, over half (n = 167) were correlated with survival in at least one of our studies.  Of these 167 TUCRs, 19 had a statistically significant Cox proportional hazard that was associated with a good prognosis, while 18 had one that was associated with a poor prognosis.  In this analysis, we also identified TUCRs that were statistically significant in our Cox Proportional Hazards and Kaplan Meier studies.  Of these, 49 were associated with a good prognosis while only 3 were associated with a poor prognosis.  The remaining 78 displayed a statistically significant difference in survival in our Kaplan-Meier analysis only (Figure 3B).  We have highlighted two TUCRs that represent a statistically significant correlation with good (uc.443, Figure 3C) or poor (uc.75, Figure 3D) prognosis using both methods.

## Methodology

### Acquiring and parsing clinical survival data

```{bash Section3_clindata, eval = FALSE}

wget http://gdac.broadinstitute.org/runs/stddata__2016_01_28/data/GBM/20160128/gdac.broadi
nstitute.org_GBM.Merge_Clinical.Level_1.2016012800.0.0.tar.gz

tar -xvzf gdac.broadinstitute.org_GBM.Merge_Clinical.Level_1.2016012800.0.0.tar.gz

mv gdac.broadinstitute.org_GBM.Merge_Clinical.Level_1.2016012800.0.0 GBM.Merge_Clinical

```

### Completing survival analysis for TUCRs

```{r Section3_surcor_TUCRs}

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis",sep=""))
}

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis/SummaryTables/",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis/SummaryTables/",sep=""))
}


if(!file.exists("GBM.clin.merged.txt")){unzip("GBM.clin.merged.zip")}

if(!is.na(n_countfile)){
  mergedcounts <- read.table(t_countfile,header = TRUE)
  
  normalcounts <- read.table(n_countfile,header = TRUE) 
  
  mergedcounts <- mergedcounts %>% left_join(normalcounts,by=c("id")) %>%
    dplyr::select(-chrom.y,-start.y,-end.y,-strand.y,-tag.y,-annot.y) %>%
    distinct()
  
  metadata <- 
  read_csv(file = t_metadatafile)
  
  n_metadata <- 
  read_csv(file = n_metadatafile)
  
  metadata <- rbind(metadata,n_metadata)
  
}else{
    mergedcounts <- read.table(t_countfile,header = TRUE) %>%
    distinct()

    metadata <- read_csv(file = t_metadatafile)
}

if(!is.na(filterannot)){
  mergedcounts <- mergedcounts %>%
    filter(tag.x == filterannot)
}

posdata <- mergedcounts[,1:7]
mergedcounts <- mergedcounts[,8:length(colnames(mergedcounts))]

is.sequential <- function(x){
  all(abs(diff(x)) == 1)
} 

match_colnames <- match(as.character(colnames(mergedcounts)),as.character(metadata$survid))

mergedcounts <- as.matrix(mergedcounts)

n_index <- which(as.character(metadata$dex) %in% "normal")
t_index <- which(as.character(metadata$dex) %in% "tumor")

vm <- function(x){
  cond <- factor(ifelse(seq(1,dim(x)[2],1) %in% t_index, 1,  0))
  d <- model.matrix(~1+cond)
  x <- t(apply(x,1,as.numeric))
  ex <- voom(x,d,plot=F)
  return(ex$E)
}

count_vm <- vm(mergedcounts)

if(is.sequential(match_colnames)){
  print("metadata rows match countfile columns")
  colnames(count_vm) <- metadata$id
}else{
  "metadata rows do not match countfile columns"
}



scal <- function(x,y){
  mean_n <- rowMeans(y)  # mean of normal
  sd_n <- apply(y,1,sd)  # SD of normal
  # z score as (value - mean normal)/SD normal
  res <- matrix(nrow=nrow(x), ncol=ncol(x))
  colnames(res) <- colnames(x)
  rownames(res) <- rownames(x)
  for(i in 1:dim(x)[1]){
    for(j in 1:dim(x)[2]){
      res[i,j] <- (x[i,j]-mean_n[i])/sd_n[i]
    }
  }
  return(res)
}

z_rna <- scal(count_vm[,t_index],count_vm[,n_index])
rownames(z_rna) <- posdata[,4]

clinical <- read.table("GBM.clin.merged.txt",header = TRUE)
#clinical <- read.table("GBM.oncolnc.merged.txt",header = TRUE)

clinical$time <- as.numeric(clinical$time)

clinical <- clinical %>%
  dplyr::select("barcode"=patient,time,status)

clinical2 <- metadata %>% left_join(clinical,by = "barcode")

#sum(clinical$patient %in% colnames(z_rna))

ind_tum <- which(unique(colnames(z_rna)) %in% clinical2$id)
ind_clin <- which(clinical2$id %in% colnames(z_rna))

out.tab <- c()
for(x in 1:nrow(count_vm)){
  ind_gene <- x
  s <- Surv(clinical2$time[ind_clin],clinical2$status[ind_clin])
  cx <- coxph(formula = s ~ count_vm[ind_gene,ind_tum])
  cx <- tidy(cx)
  out.tab <- rbind(out.tab,cx)
}

surv_TUCR <- cbind(posdata,out.tab)
surv_TUCR <- surv_TUCR %>% dplyr::select(-term)

write_csv(surv_TUCR,paste(outputdir,"/SurvivalAnalysis/SummaryTables/",disease,"_survival_TUCRs.csv",sep=""))

if(makekpmplots == TRUE){

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis/tucrKPMplots",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis/tucrKPMplots",sep=""))
}

km_countdata <- mergedcounts
colnames(km_countdata) <- metadata$id
posdata$median <- rowMedians(mergedcounts)

mergedcounts <- mergedcounts[,complete.cases(clinical2)]

probs <- c(0.25,0.5,0.75)
q <- rowQuantiles(mergedcounts, probs = probs)
posdata$n25 <- q[,1]
posdata$n75 <- q[,3]
posdata <- posdata %>%
  dplyr::select("TUCR"=id,median,n25,n75)
km_TUCRs <- cbind(posdata,km_countdata[,complete.cases(clinical2)]) 

km_TUCRs <- km_TUCRs %>%
  gather(key = "id", value = "count",-TUCR,-median,-n75,-n25) %>%
  mutate(group = ifelse(count>=n75,"high",ifelse(count<=n25,"low",NA))) %>%
  distinct %>%
  dplyr::select(TUCR,median,id,group) %>%
  left_join(clinical2,by="id") %>%
  dplyr::filter(median != 0)

TUCRids <- as.character(posdata$TUCR)
i = 1

ptable <- data.frame(matrix(ncol=3,nrow=0, dimnames=list(NULL, c("TUCR","pvalue","method"))))

for(i in 1:length(TUCRids)){
  print(i)
  skip_to_next <- FALSE
  TUCRsurv <- as.character(TUCRids[i])
  #TUCR <- "uc.1"
  kmdata <- km_TUCRs %>%
    dplyr::filter(TUCR == TUCRsurv) %>%
    dplyr::select(TUCR,id,group,time,status) 
  fit <- survfit(Surv(time, status) ~ group, data = kmdata)
  p <- tryCatch(ggsurvplot(fit,data=kmdata,conf.int = TRUE,pval = TRUE,risk.table = TRUE),
                error = function(e) { skip_to_next <<- TRUE})
  #p <- ggsurvplot(fit,data=kmdata,conf.int = TRUE,pval = TRUE,risk.table = TRUE)
                
  if(skip_to_next) { 
    rbinder <- cbind(as.character(TUCRsurv),NA,NA)
    ptable[i,] <- rbinder
    next } 
  ggsave(file=paste(outputdir,"/SurvivalAnalysis/tucrKPMplots/",disease,"_",TUCRsurv,"_kpmplot.png",sep = ""),
         plot = print(p))
  p2value <- surv_pvalue(fit,  data = kmdata,method = "survdiff")
  rbinder <- cbind(as.character(TUCRsurv),p2value$pval,p2value$method)
  ptable[i,] <- rbinder
}}

write_csv(ptable,paste(outputdir,"/SurvivalAnalysis/SummaryTables/",disease,"_kpm_summary_TUCRs.csv",sep=""))

```

### Writing a script to generate a volcano plot for survival

```{r Section3_volcanosurv}

### Volcano plot

volcanosurv <- function (res,genes = "all",title = paste("TUCRs correlated with survival in ",disease,sep=""), output = paste(disease,"_results__survival_volcanoplot.png",sep=""),height = 7.5, width = 9, dpi = 300){
  #res <- res_surv
  #genes = c("uc.110","uc.62")
  #title = paste("TUCR correlation with patient survival in ",disease,sep="")
  #output = paste(outputdir,"/intergenic_tucr_results_volcanosurv.png",sep="")
  i <- 1
  vres <- res
  vres <- vres %>% mutate(gene="",Survival="",color="")
  for (i in 1:length(vres$id)){
  ifelse(is.na(vres$pvalue[i]),vres$pvalue[i] <- 1,vres$pvalue[i] <- vres$pvalue[i])
    
  ifelse(genes!="all",ifelse(!is.na(match(vres$id[i],genes)),vres$gene[i] <- as.character(vres$id[i]), ""),vres$gene[i] <- vres$id[i])
  
  ifelse((vres$pvalue[i] <0.05 & vres$p.value[i] <0.05 & vres$estimate[i] < 0),{vres$Survival[i] <- "Significant (Both, Good Prognosis)";vres$color[i] <- "red";},
  ifelse((vres$pvalue[i] <0.05 & vres$p.value[i] <0.05 & vres$estimate[i] > 0),{vres$Survival[i] <- "Significant (Both, Poor Prognosis)";vres$color[i] <- "blue";},
  ifelse((vres$pvalue[i] >0.05 & vres$p.value[i] <0.05 & vres$estimate[i] < 0),{vres$Survival[i] <- "Significant (CH, Good Prognosis)";vres$color[i] <- "green";},
  ifelse((vres$pvalue[i] >0.05 & vres$p.value[i] <0.05 & vres$estimate[i] > 0),{vres$Survival[i] <- "Significant (CH, Poor Prognosis)";vres$color[i] <- "purple";},
  ifelse((vres$pvalue[i] <0.05 & vres$p.value[i] >0.05),{vres$Survival[i] <- "Significant (KM)";vres$color[i] <- "black";},
  ifelse({vres$Survival[i] <- "Not significant";vres$color[i] <- "lightgray";}))))))}
  
  vres <- vres %>%
  arrange(desc(Survival))

  
  ## plot
if(repel==TRUE){p <- ggplot(vres) +
        geom_point(aes(x=estimate, y=-log10(as.numeric(p.value)),col=color)) +
        scale_color_identity(guide = "legend", labels = vres$Survival, breaks = vres$color) +
        ggtitle(title) +
        labs(x = "Cox Estimated Proportional Hazard",
        y = "-log10 P-Value (CH)",
        color = "Legend")+
        theme(plot.title = element_text(size = rel(1.5), hjust = 0.5, face="bold"),
              axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) +
        geom_text_repel(aes(x=estimate, y=-log10(as.numeric(p.value)),label = gene),force=50)
}else{
  p <- ggplot(vres) +
        geom_point(aes(x=estimate, y=-log10(as.numeric(pvalue)),col=color)) +
    scale_color_identity(guide = "legend", labels = vres$Survival, breaks = vres$color) +
        + ggtitle(title) +
        labs(x = "Cox Estimated Proportional Hazard",
        y = "-log10 P-Value (CH)",
        color = "Legend") +
        theme(plot.title = element_text(size = rel(1.5), hjust = 0.5, face="bold"),
              axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))}
ggsave(output, width = width, height = height, dpi = dpi)
}

```

### Summarize Survival Data 

```{r Section3_summary surv}

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/",sep=""))
}

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/VolcanoPlots/",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/VolcanoPlots/",sep=""))
}

if(!dir.exists(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",sep=""))){
  dir.create(paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",sep=""))
}

genes <- ""

surv_TUCR <- read.csv(paste(outputdir,"/SurvivalAnalysis/SummaryTables/",disease,"_survival_TUCRs.csv",sep=""),header=TRUE)

ptable <- read.csv(paste(outputdir,"/SurvivalAnalysis/SummaryTables/",disease,"_kpm_summary_TUCRs.csv",sep=""),header=TRUE) %>%
  dplyr::select("id"=TUCR,pvalue,method)

res_surv <- inner_join(ptable,surv_TUCR,by="id")

res_surv_sum <- res_surv

res_surv_sum <- res_surv_sum %>% mutate(gene="",Survival="",color="")

tucr_annot <- read.table("BEDFiles/hg38.ultraconserved.bed") %>%
  dplyr::select("id" = V4, "annot" = V7)

res_surv_sum <- res_surv_sum %>%
  left_join(tucr_annot,by="id")

annot_unique <- as.character(unique(tucr_annot$annot))

annotation <- "All"

res_surv_sum2 <- res_surv_sum

for (i in 1:length(res_surv_sum2$id)){
  #print(as.character(res_surv_sum2$id[i]))
  ifelse(is.na(res_surv_sum2$pvalue[i]),res_surv_sum2$pvalue[i] <- 1,res_surv_sum2$pvalue[i] 
         <- res_surv_sum2$pvalue[i])
    
  ifelse(genes!="all",ifelse(!is.na(match(res_surv_sum2$id[i],genes)),
                             res_surv_sum2$gene[i] <- as.character(res_surv_sum2$id[i]), ""),
                                  res_surv_sum2$gene[i] <- res_surv_sum2$id[i])
  
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] <0.05 & 
            res_surv_sum2$estimate[i] < 0),
         {res_surv_sum2$Survival[i] <- "Significant (Both, Good Prognosis)";res_surv_sum2$color[i] <- "red";},
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] > 0),
         {res_surv_sum2$Survival[i] <- "Significant (Both, Poor Prognosis)";res_surv_sum2$color[i] <- "blue";},
  ifelse((res_surv_sum2$pvalue[i] >0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] < 0),
         {res_surv_sum2$Survival[i] <- "Significant (CH, Good Prognosis)";res_surv_sum2$color[i] <- "green";},
  ifelse((res_surv_sum2$pvalue[i] >0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] > 0),
         {res_surv_sum2$Survival[i] <- "Significant (CH, Poor Prognosis)";res_surv_sum2$color[i] <- "purple";},
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] >0.05),
         {res_surv_sum2$Survival[i] <- "Significant (KM)";res_surv_sum2$color[i] <- "black";},
  {res_surv_sum2$Survival[i] <- "Not significant";res_surv_sum2$color[i] <- "lightgray";})))))}

res_surv_sum2 <- res_surv_sum2 %>%
  group_by(Survival) %>%
  summarise(count = n(),color) %>%
  distinct() %>%
  arrange(desc(Survival))

write.csv(res_surv_sum2,file=paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",disease,"_",annotation,"_tucr_surv_table.csv",sep=""))

p <- ggplot(res_surv_sum2, aes(x=Survival,y=count,fill=color)) + geom_bar(stat="identity", width = 0.7) + 
  scale_fill_identity(guide = "legend", labels = res_surv_sum2$Survival, breaks = res_surv_sum2$color) + 
  labs(y = "# of TUCRs", fill = "Legend") + 
  theme(
plot.title = element_text(size=rel(1.5), face="bold",hjust = 0.5),
axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
axis.text.x = element_blank())

ggsave(file=paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",disease,"_",annotation,"_tucr_surv_bar.png",sep=""),plot = print(p), width = 5, height = 5, dpi = 300)

res_surv_sum3 <- res_surv_sum

volcanosurv(res_surv_sum3, genes = "", title = paste(annotation," TUCR correlation with patient survival in ",disease,sep=""),output = paste(outputdir,"/SurvivalAnalysis/SummaryFigures/VolcanoPlots/",disease,"_",annotation,"_tucr_results_volcanosurv.png",sep=""))

h <- 1

for (h in 1:length(annot_unique)){
  annotation <- as.character(annot_unique[h])  
  print(annotation)
  res_surv_sum2 <- res_surv_sum %>%
    filter(annot == annotation)

for (i in 1:length(res_surv_sum2$id)){
  #print(as.character(res_surv_sum2$id[i]))
  ifelse(is.na(res_surv_sum2$pvalue[i]),res_surv_sum2$pvalue[i] <- 1,res_surv_sum2$pvalue[i] 
         <- res_surv_sum2$pvalue[i])
    
  ifelse(genes!="all",ifelse(!is.na(match(res_surv_sum2$id[i],genes)),
                             res_surv_sum2$gene[i] <- as.character(res_surv_sum2$id[i]), ""),
                                  res_surv_sum2$gene[i] <- res_surv_sum2$id[i])
  
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] <0.05 & 
            res_surv_sum2$estimate[i] < 0),
         {res_surv_sum2$Survival[i] <- "Significant (Both, Good Prognosis)";res_surv_sum2$color[i] <- "red";},
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] > 0),
         {res_surv_sum2$Survival[i] <- "Significant (Both, Poor Prognosis)";res_surv_sum2$color[i] <- "blue";},
  ifelse((res_surv_sum2$pvalue[i] >0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] < 0),
         {res_surv_sum2$Survival[i] <- "Significant (CH, Good Prognosis)";res_surv_sum2$color[i] <- "green";},
  ifelse((res_surv_sum2$pvalue[i] >0.05 & res_surv_sum2$p.value[i] <0.05 &
            res_surv_sum2$estimate[i] > 0),
         {res_surv_sum2$Survival[i] <- "Significant (CH, Poor Prognosis)";res_surv_sum2$color[i] <- "purple";},
  ifelse((res_surv_sum2$pvalue[i] <0.05 & res_surv_sum2$p.value[i] >0.05),
         {res_surv_sum2$Survival[i] <- "Significant (KM)";res_surv_sum2$color[i] <- "black";},
  {res_surv_sum2$Survival[i] <- "Not significant";res_surv_sum2$color[i] <- "lightgray";})))))}

res_surv_sum2 <- res_surv_sum2 %>%
  group_by(Survival) %>%
  summarise(count = n(),color) %>%
  distinct() %>%
  arrange(desc(Survival))

write.csv(res_surv_sum2,file=paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",disease,"_",annotation,"_tucr_surv_table.csv",sep=""))

p <- ggplot(res_surv_sum2, aes(x=Survival,y=count,fill=color)) + geom_bar(stat="identity", width = 0.7) + 
  scale_fill_identity(guide = "legend", labels = res_surv_sum2$Survival, breaks = res_surv_sum2$color) + 
  labs(y = "# of TUCRs", fill = "Legend") + 
  theme(
plot.title = element_text(size=rel(1.5), face="bold",hjust = 0.5),
axis.title = element_text(size = rel(1.25), face="bold"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
axis.text.x = element_blank())

ggsave(file=paste(outputdir,"/SurvivalAnalysis/SummaryFigures/BarGraphs/",disease,"_",annotation,"_tucr_surv_bar.png",sep=""),plot = print(p), width = 5, height = 5, dpi = 300)

res_surv_sum3 <- res_surv_sum

volcanosurv(res_surv_sum3, genes = "", title = paste(annotation," TUCR correlation with patient survival in ",disease,sep=""),output = paste(outputdir,"/SurvivalAnalysis/SummaryFigures/VolcanoPlots/",disease,"_",annotation,"_tucr_results_volcanosurv.png",sep=""))
}

```

# Section 4: TUCRs are coregulated with genes that have known functions

## Results 

Many genes have published functions and mechanisms of action.  Gene that are coregulated have correlated differential expression.  Coregulated genes may share a biological function.  We have predicted TUCR function by identifying coregulated genes with known functions.  Using a guilt-by-association analysis pipeline, we first identified determined the deregulation of all known coding and non-coding genes using the CHESS annotation database.  This dataset contains known Refseq and Ensembl genes in additional to some novel genes that were discovered in 2018.  We the constructed a correlation matrix of TUCRs to other TUCRs and “CHESS genes” using the Spearman correlation.  This correlation measures the relationship of the gene to the TUCR as TUCR deregulation decreases.  If the TUCR increases and the coregulated gene decreases, the correlation will increase and approach a perfect positive correlated value of 1.  If the TUCR increases and the coregulated gene decreases, the correlation will decrease and approach a perfect negative correlation of -1.  Genes with no correlation to the TUCR are those with a correlation close to zero, specifically between -0.3 and 0.3.  

Coregulated genes lists for each TUCR were subset into separate lists by directionality (positive/negative).  These lists were subject to gene ontology (GO) term analysis.  For each TUCR, lists of biological processes, molecular functions, or cellular compartments were predicted for the list of coregulated genes.  This list was cross referenced and filtered to a control list of “cancer” related GO Terms; these terms were generated by performing the same guilt-by-association analysis on known oncogenes and tumor suppressors from the CancerMine database.  The final matrix was filtered to statistically significant (FDR <=0.05) GO Terms only. Then a heatmap of the directionality of significant positive (red), negative (blue), and uncorrelated biological processes (white) was generated for GBM (Figure 5A) and LGG (Figure 6A).  These heatmaps were sorted by frequency of occurrence, and the 10 most represented positive (Figure 5B, Figure 6B) and negative (Figure 5C, Figure 6C) associations are highlighted.  These analyses were also performed to determine TUCR molecular functions (MF, Supplementary Figures 2 and 3) and cellular compartments (CC, Supplementary Figures 4 and 5).  The full list of all TUCR GO Terms was also compiled.  (Supplementary Table 1) 

## Methodology

### Identify DE TUCRs that are correlated with each other

```{r Section4_correlations, eval=FALSE}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/",sep=""))
}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/correlations",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/correlations",sep=""))
}

if(useintermediate==FALSE){
TUCRids <- read.table(countfilename,header = TRUE)
TUCRids <- as.character(TUCRids[,4])
normcounts <- read.table("normal_mergedcounts.txt",header = TRUE)
expcounts <- read.table(mergedcountfile,header = TRUE)
posdata <- normcounts[,1:4]
normcounts <- normcounts[4:ncol(normcounts)]
expcounts <- expcounts[4:ncol(expcounts)]
tucrcounts <- inner_join(posdata,normcounts,by="id")
tucrcounts <- inner_join(tucrcounts,expcounts,by="id")

metadata <- read_csv(file = metadatafile)



tucr.cor <- tucrcounts[,5:ncol(tucrcounts)]
rownames(tucr.cor) <- as.character(tucrcounts[,4])

posdata <- tucrcounts[,1:4]

countdata <- as.matrix(tucr.cor)

n_index <- c(seq(1,5))
t_index <- c(seq(6,ncol(countdata)))

vm <- function(x){
  cond <- factor(ifelse(seq(1,dim(x)[2],1) %in% t_index, 1,  0))
  d <- model.matrix(~1+cond)
  x <- t(apply(x,1,as.numeric))
  ex <- voom(x,d,plot=F)
  return(ex$E)
}

count_vm <- vm(countdata)
colnames(count_vm) <- metadata$barcode
posdata$median <- rowMedians(as.matrix(count_vm)) 

tucr.cor <- cbind(posdata[,4:5],count_vm)

tucr.cor.matrix <- data.frame(row.names = posdata[,4])


i=3

for(i in 3:ncol(tucr.cor)){
  print(i)
  tucr.cor.matrix[,i-2] <- tucr.cor[,i]/tucr.cor[,2]


colnames(tucr.cor.matrix) <- metadata$id
tucr.cor.matrix2 <- t(as.data.frame(apply(as.data.frame(tucr.cor.matrix),1:2,function(x) {ifelse(x>=1,x,-(1/x))})))
tucr.cor.matrix2 <- as.data.frame(tucr.cor.matrix2)
tucr.cor.matrix2 <- tucr.cor.matrix2[1:180,]
geneindex <- rownames(tucr.cor.matrix)}

save(tucr.cor.matrix2,geneindex,TUCRids,file="inter.rData")
rm(list=ls())

load(file="inter.rData")

tucr.cor.matrix3 <- cor(tucr.cor.matrix2,method="spearman", use = "complete.obs")

save(tucr.cor.matrix3,geneindex,TUCRids,file=intermediatefile)
rm(list=ls())
load(file=intermediatefile)}else{
  load("lgg_matrixintermediate.rData")
}

header <- head(tucr.cor.matrix3)

summarycor <- data.frame(searchTUCR=character(0),ngenes=integer(0),meancor=numeric(0),mediancor=numeric(0),mincor=numeric(0),maxcor=numeric(0))

i = 1

for(i in 1:length(TUCRids)){
  print(i)
  print(TUCRids[i])
  searchTUCR <- TUCRids[i]
  #searchTUCR <- "uc.110"
###uc.110 is at row 20972 in tucr.cor.matrix3 via manual confirmation.
tucr.cor.matrix.match <- tucr.cor.matrix3[match(searchTUCR,geneindex),]
tucr.cor.matrix.match <- as.data.frame(tucr.cor.matrix.match)
tucr.cor.matrix.match.plus <- tucr.cor.matrix.match %>% 
  mutate(partner = geneindex) %>%
  mutate(gene = searchTUCR) %>%
  dplyr::select(gene,partner,"cor"=tucr.cor.matrix.match) %>%
  dplyr::filter(cor>=0.3 & partner != searchTUCR) %>%
  dplyr::mutate(direction = "positive")

write.csv(tucr.cor.matrix.match.plus,
          paste(outputdir,"/GuiltAnalysis/correlations/",searchTUCR,"_plus_correlations.csv",sep=""))

tucr.cor.matrix.match.minus <- tucr.cor.matrix.match %>% 
  mutate(partner = geneindex) %>%
  mutate(gene = searchTUCR) %>%
  dplyr::select(gene,partner,"cor"=tucr.cor.matrix.match) %>%
  dplyr::filter(cor<=-0.3 & partner != searchTUCR) %>%
  dplyr::mutate(direction = "negative")

write.csv(tucr.cor.matrix.match.minus,
          paste(outputdir,"/GuiltAnalysis/correlations/",searchTUCR,"_minus_correlations.csv",sep=""))

meancor <- mean(tucr.cor.matrix.match$tucr.cor.matrix.match,na.rm=TRUE)
mediancor <- median(tucr.cor.matrix.match$tucr.cor.matrix.match,na.rm=TRUE)
ngenes <- length(tucr.cor.matrix.match$tucr.cor.matrix.match)
mincor <- min(tucr.cor.matrix.match$tucr.cor.matrix.match,na.rm=TRUE)
maxcor <- max(tucr.cor.matrix.match$tucr.cor.matrix.match,na.rm=TRUE)
newrow <- cbind(searchTUCR,ngenes,meancor,mediancor,mincor,maxcor)
summarycor <- rbind(summarycor,newrow)}

summarycor %>%
readr::write_excel_csv(here::here(paste(outputdir,"/GuiltAnalysis/correlations",sep=""),paste("cor_summary.csv",sep="")))

```

### Generate GO Terms for coregulated genes

```{r GO Terms, eval=FALSE}
 if(!dir.exists(paste(outputdir,"/GuiltAnalysis",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis",sep=""))
 }

filenames <- list.files(paste(outputdir,"/GuiltAnalysis/correlations",sep=""))

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/GO_terms",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/GO_terms",sep=""))
}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/GO_terms_bp",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/GO_terms_bp",sep=""))
}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/GO_terms_mf",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/GO_terms_mf",sep=""))
}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/GO_terms_cc",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/GO_terms_cc",sep=""))
}

allgo <- data.frame(matrix(ncol=7,nrow=0, dimnames=list(NULL, c("GO Term","Ont","N","DE","P.DE","direction","gene"))))

allgo_bp <- data.frame(matrix(ncol=7,nrow=0, dimnames=list(NULL, c("GO Term","Ont","N","DE","P.DE","direction","gene"))))

allgo_mf <- data.frame(matrix(ncol=7,nrow=0, dimnames=list(NULL, c("GO Term","Ont","N","DE","P.DE","direction","gene"))))

allgo_cc <- data.frame(matrix(ncol=7,nrow=0, dimnames=list(NULL, c("GO Term","Ont","N","DE","P.DE","direction","gene"))))

i = 2

for(i in 2:length(filenames)){
  print(i)
  skip_to_next <- FALSE
  df <- read.csv(paste(outputdir,"/GuiltAnalysis/correlations/",filenames[i],sep=""))
  gene <- as.character(df$gene[1])
  
  if(length(df[,1] > 0)){
  
  df2 <- cSplit(df, 'partner', sep="___", type.convert=FALSE)
  
  df2 <- df2 %>% arrange(desc(cor))
  
  IDs <- df2$partner_1
  
  entrezIDs <- tryCatch(mapIds(org.Hs.eg.db, IDs, 'ENTREZID', 'SYMBOL'), error = function(e) { skip_to_next <<- TRUE})
  
  if(skip_to_next) { next } 

  df2$entrez <- entrezIDs
  if(str_detect(filenames[i],"minus")){direction <- -1}else{
    if(str_detect(filenames[i],"plus")){direction <- 1}else{direction <- 0}
  }
  
  Genes<-entrezIDs
  g <- goana(Genes)
  topGO <- topGO(g) 
  
  topGO_all <- topGO %>%
    mutate(direction = direction) %>%
    mutate(gene = gene)
  
  write.csv(topGO_all,paste(outputdir,"/GuiltAnalysis/GO_terms/",filenames[i],sep=""))
  topGO_bp <- topGO %>%
    filter(Ont == "BP") %>%
    mutate(direction = direction) %>%
    mutate(gene = gene)
  
  write.csv(topGO_bp,paste(outputdir,"/GuiltAnalysis/GO_terms_bp/",filenames[i],sep=""))
  topGO_mf <- topGO %>%
    filter(Ont == "MF") %>%
    mutate(direction = direction) %>%
    mutate(gene = gene)
  
  write.csv(topGO_mf,paste(outputdir,"/GuiltAnalysis/GO_terms_mf/",filenames[i],sep=""))
  topGO_cc <- topGO %>%
    filter(Ont == "CC") %>%
    mutate(direction = direction) %>%
    mutate(gene = gene)
  
  write.csv(topGO_cc,paste(outputdir,"/GuiltAnalysis/GO_terms_cc/",filenames[i],sep=""))
  }else{}
  allgo <- rbind(allgo,topGO)
  allgo_bp <- rbind(allgo_bp,topGO_bp)
  allgo_mf <- rbind(allgo_mf,topGO_mf)
  allgo_cc <- rbind(allgo_cc,topGO_cc)
}

write_csv(allgo,paste(outputdir,"/GuiltAnalysis/GOterm_all_summary_TUCRs.csv",sep=""))

write_csv(allgo_bp,paste(outputdir,"/GuiltAnalysis/GOterm_bp_summary_TUCRs.csv",sep=""))

write_csv(allgo_mf,paste(outputdir,"/GuiltAnalysis/GOterm_mf_summary_TUCRs.csv",sep=""))

write_csv(allgo_cc,paste(outputdir,"/GuiltAnalysis/GOterm_cc_summary_TUCRs.csv",sep=""))
```

### Summarize GO term data for oncogenes and tumor suppressors

```{r summary GO Terms GSEA, eval=FALSE}

if(!dir.exists(paste(outputdir,"/GuiltAnalysis/Cancermine/",sep=""))){
  dir.create(paste(outputdir,"/GuiltAnalysis/Cancermine/",sep=""))
}

GSEA <- read.csv("GSEA.csv",header = TRUE)

annotations <- as.character(unique(GSEA$annot))

topGO_onctsg <- ""

i <- 1

for(i in 1:length(annotations)){
  
print(annotations[i])

group <- GSEA %>%
  filter(annot == annotations[i])

entrezIDs <- mapIds(org.Hs.eg.db, as.character(group$gene), 'ENTREZID', 'SYMBOL')

Genes <- entrezIDs
g <- goana(Genes)
topGO <- topGO(g)
topGO$annot <- annotations[i]

topGO_onctsg <- rbind(topGO_onctsg,topGO)
}

topGO_cancermine <- topGO_onctsg %>%
    filter(Ont == "BP") %>%
    dplyr::select(Term,P.DE,annot)

cancerTerms <- topGO_cancermine %>%
  dplyr::select(Term) %>%
  unique()
  
write.csv(topGO_cancermine,paste(outputdir,"/GuiltAnalysis/Cancermine/topGO_cancermine.csv",sep=""))

cancerTerms_summary <- read.csv(paste(outputdir,"/GuiltAnalysis/Cancermine/topGO_cancermine.csv",sep=""),header=TRUE) %>%
  group_by(Term) %>%
  summarise(n = n())


```  

### Summarize GO Term Data (new)

```{r summary GO Terms new}

cancerTerms <- read.csv(paste(outputdir,"/GuiltAnalysis/Cancermine/topGO_cancermine.csv",sep=""),header=TRUE) %>%
  dplyr::select(Term) %>%
  distinct()

allgo <- read.csv(paste(outputdir,"/GuiltAnalysis/GOterm_all_summary_TUCRs.csv",sep=""),header=TRUE,stringsAsFactors=FALSE)
allgo <- allgo %>%
  dplyr::select(Term)

rbinder.allgo <- allgo
heatmap.allgo <- data.frame(matrix(ncol=3,nrow=0, dimnames=list(NULL, c("Term","gene","direction"))))

i <- 1

tucr_annot <- read.table("BEDFiles/hg38.ultraconserved.bed") %>%
  dplyr::select("id" = V5, "annot" = V7)

annot_unique <- as.character(unique(tucr_annot$annot))

h <- 1

  annotation <- "All"  
  print(annotation)
  TUCRids <- tucr_annot %>%
    dplyr::select(id)

for(i in 1:length(TUCRids$id)){
#for(i in 1:30){
  print(i)
  TUCR <- TUCRids[i,]
  skip_to_next_p <<- FALSE
  skip_to_next_n <<- FALSE
  positive <- tryCatch(read.csv(paste(outputdir,"/GuiltAnalysis/GO_Terms/",TUCR,"_plus_correlations.csv",sep=""),
                       header=TRUE), error = function(e) { skip_to_next_p <<- TRUE})

  negative <- tryCatch(read.csv(paste(outputdir,"/GuiltAnalysis/GO_Terms/",TUCR,"_minus_correlations.csv",sep=""),
                       header=TRUE), error = function(e) { skip_to_next_n <<- TRUE})

  
  if(skip_to_next_p & skip_to_next_n) { next } 
  
  pos_neg <- rbind(positive,negative)
  pos_neg <- pos_neg %>%
    filter(P.DE <= 0.05) %>%
    dplyr::select(Term,gene,direction)
  
  rbinder.allgo.TUCR <- dplyr::left_join(rbinder.allgo,pos_neg,by="Term")
  rbinder.allgo.TUCR$gene <- TUCR
  heatmap.allgo <- rbind(heatmap.allgo,rbinder.allgo.TUCR)
}


heatmap.allgo[is.na(heatmap.allgo)] <- 0
heatmap.allgo2 <- heatmap.allgo[which(as.character(heatmap.allgo$Term) %in% as.character(cancerTerms$Term)),]

#heatmap.allgo2 <- heatmap.allgo

heatmap.allgo2 <- heatmap.allgo2 %>%
  distinct() %>%
  dplyr::group_by(Term,gene) %>%
  mutate(n=n(),onedirection = ifelse(n>1,0,direction)) %>%
  dplyr::select(-n,-direction) %>%
  distinct() %>%
  group_by(Term,onedirection) %>%
  mutate(ysums = ifelse(onedirection==0,0,sum(onedirection))) %>%
  ungroup() %>%
  group_by(Term) %>%
  mutate(y = sum(abs(onedirection))) %>%
  ungroup() %>%
  group_by(gene) %>%
  mutate(x = sum(onedirection)) %>%
  ungroup() %>%
  arrange(desc(y)) 
  #spread(Term,onedirection) %>%
  #ungroup()



colors <- colorRampPalette(c("red","white","blue"))(3)

heatmap.allgo2$onedirection <- factor(heatmap.allgo2$onedirection)
N <- nlevels(heatmap.allgo2$onedirection)

p <- ggplot(data = heatmap.allgo2,mapping = aes(x = reorder(gene,x),y = reorder(Term,y), fill = onedirection)) +
guides(fill = guide_legend(reverse=TRUE)) + 
  geom_tile() +
   scale_fill_manual(values=colors, breaks=levels(heatmap.allgo2$onedirection)[seq(1, N, by=1)]) + 
  ggtitle(paste(annotation," TUCR cancer associated functions in ",disease,sep="")) + 
  xlab(paste("TUCRs (n=",length(unique(heatmap.allgo2$gene)),")",sep = "")) + 
  ylab(paste("Cancer associated GO Terms (n=",length(unique(heatmap.allgo2$Term)),")",sep = "")) +
  labs(fill = "Correlation") +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggsave(p,file=paste(outputdir,"/GuiltAnalysis/GOTerms_heatmap_",annotation,".png",sep=""))

chart.mostrep <- heatmap.allgo2 %>%
  dplyr::select(Term,y) %>%
  distinct() %>%
  arrange(desc(y))

chart.allgo.mostrep <- chart.mostrep[1:8,]

chart.allgo.up <- heatmap.allgo2 %>%
  filter(ysums>0) %>%
  dplyr::select(Term,ysums) %>%
  distinct() %>%
  arrange(desc(ysums))

chart.allgo.up.top10 <- chart.allgo.up[1:10,]

chart.allgo.down <- heatmap.allgo2 %>%
  filter(ysums<0) %>%
  dplyr::select(Term,ysums) %>%
  distinct() %>%
  arrange(ysums)

chart.allgo.down.bottom10 <- chart.allgo.down[1:10,]

p <- ggplot(chart.allgo.mostrep, aes(x=reorder(Term,y),y=y,fill=Term)) +
geom_bar(stat="identity", width = 0.7,color="black") + geom_text(aes(label=round(y,2)), hjust=2, color="black", size=rel(7.5)) + ggtitle("") +xlab("") + ylab("# of TUCRs") + 
  theme(
  plot.title = element_text(size=rel(1.5), face="bold",hjust = 0.5),
axis.title = element_text(size = rel(1.25), face="bold"),
legend.title = element_blank(),
legend.position = "none",
axis.text.x = element_text(size=rel(2.0)),
axis.text.y = element_text(size=rel(2.0)),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) + coord_flip()

ggsave(file=paste(outputdir,"/GuiltAnalysis/tucr_allgo_",annotation,".png",sep=""),plot = print(p), width = 15, height = 10, dpi = 300) 
}

for (h in 1:length(annot_unique)){
  annotation <- as.character(annot_unique[h])  
  print(annotation)
  TUCRids <- tucr_annot %>%
    filter(annot == annotation) %>%
    dplyr::select(id)

for(i in 1:length(TUCRids$id)){
#for(i in 1:30){
  print(i)
  TUCR <- TUCRids[i,]
  skip_to_next_p <<- FALSE
  skip_to_next_n <<- FALSE
  positive <- tryCatch(read.csv(paste(outputdir,"/GuiltAnalysis/GO_Terms/",TUCR,"_plus_correlations.csv",sep=""),
                       header=TRUE), error = function(e) { skip_to_next_p <<- TRUE})

  negative <- tryCatch(read.csv(paste(outputdir,"/GuiltAnalysis/GO_Terms/",TUCR,"_minus_correlations.csv",sep=""),
                       header=TRUE), error = function(e) { skip_to_next_n <<- TRUE})

  
  if(skip_to_next_p & skip_to_next_n) { next } 
  
  pos_neg <- rbind(positive,negative)
  pos_neg <- pos_neg %>%
    filter(P.DE <= 0.05) %>%
    dplyr::select(Term,gene,direction)
  
  rbinder.allgo.TUCR <- dplyr::left_join(rbinder.allgo,pos_neg,by="Term")
  rbinder.allgo.TUCR$gene <- TUCR
  heatmap.allgo <- rbind(heatmap.allgo,rbinder.allgo.TUCR)
}


heatmap.allgo[is.na(heatmap.allgo)] <- 0
heatmap.allgo2 <- heatmap.allgo[which(as.character(heatmap.allgo$Term) %in% as.character(cancerTerms$Term)),]

#heatmap.allgo2 <- heatmap.allgo

heatmap.allgo2 <- heatmap.allgo2 %>%
  distinct() %>%
  dplyr::group_by(Term,gene) %>%
  mutate(n=n(),onedirection = ifelse(n>1,0,direction)) %>%
  dplyr::select(-n,-direction) %>%
  distinct() %>%
  group_by(Term,onedirection) %>%
  mutate(ysums = ifelse(onedirection==0,0,sum(onedirection))) %>%
  ungroup() %>%
  group_by(Term) %>%
  mutate(y = sum(abs(onedirection))) %>%
  ungroup() %>%
  group_by(gene) %>%
  mutate(x = sum(onedirection)) %>%
  ungroup() %>%
  arrange(desc(y)) 
  #spread(Term,onedirection) %>%
  #ungroup()



colors <- colorRampPalette(c("red","white","blue"))(3)

heatmap.allgo2$onedirection <- factor(heatmap.allgo2$onedirection)
N <- nlevels(heatmap.allgo2$onedirection)

p <- ggplot(data = heatmap.allgo2,mapping = aes(x = reorder(gene,x),y = reorder(Term,y), fill = onedirection)) +
guides(fill = guide_legend(reverse=TRUE)) + 
  geom_tile() +
   scale_fill_manual(values=colors, breaks=levels(heatmap.allgo2$onedirection)[seq(1, N, by=1)]) + 
  ggtitle(paste(annotation," TUCR cancer associated functions in ",disease,sep="")) + 
  xlab(paste("TUCRs (n=",length(unique(heatmap.allgo2$gene)),")",sep = "")) + 
  ylab(paste("Cancer associated GO Terms (n=",length(unique(heatmap.allgo2$Term)),")",sep = "")) +
  labs(fill = "Correlation") +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggsave(p,file=paste(outputdir,"/GuiltAnalysis/GOTerms_heatmap_",annotation,".png",sep=""))

chart.mostrep <- heatmap.allgo2 %>%
  dplyr::select(Term,y) %>%
  distinct() %>%
  arrange(desc(y))

chart.allgo.mostrep <- chart.mostrep[1:8,]

chart.allgo.up <- heatmap.allgo2 %>%
  filter(ysums>0) %>%
  dplyr::select(Term,ysums) %>%
  distinct() %>%
  arrange(desc(ysums))

chart.allgo.up.top10 <- chart.allgo.up[1:10,]

chart.allgo.down <- heatmap.allgo2 %>%
  filter(ysums<0) %>%
  dplyr::select(Term,ysums) %>%
  distinct() %>%
  arrange(ysums)

chart.allgo.down.bottom10 <- chart.allgo.down[1:10,]

p <- ggplot(chart.allgo.mostrep, aes(x=reorder(Term,y),y=y,fill=Term)) +
geom_bar(stat="identity", width = 0.7,color="black") + geom_text(aes(label=round(y,2)), hjust=2, color="black", size=rel(7.5)) + ggtitle("") +xlab("") + ylab("# of TUCRs") + 
  theme(
  plot.title = element_text(size=rel(1.5), face="bold",hjust = 0.5),
axis.title = element_text(size = rel(1.25), face="bold"),
legend.title = element_blank(),
legend.position = "none",
axis.text.x = element_text(size=rel(2.0)),
axis.text.y = element_text(size=rel(2.0)),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) + coord_flip()

ggsave(file=paste(outputdir,"/GuiltAnalysis/tucr_allgo_",annotation,".png",sep=""),plot = print(p), width = 15, height = 10, dpi = 300) 
}
```  